<html lang="en">
<!--
Planning Checklist
- Structure & Config: Single-file app; CONFIG object for all tunables.
- UI Layout: Sidebar with tools/controls; full-window canvas; HUD/tooltip overlays.
- Painting Logic: Brush spawns Gas/Rock/Ice (or Erase); mass/rate; V to throw.
- Physics: 2D gravity with softening; semi-implicit leapfrog; inelastic merging.
- Rendering: Bodies, trails, vectors, star color by mass; rings; HUD; inspector.
- Save/Load: Persist scene + config to localStorage; seed demo and random belt.
- Performance: Spatial hashing for collisions; cap bodies; fading trails.
-->
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Solar System Sandbox</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #0b0e14;
      --panel: #11151f;
      --panel-2: #0f1320;
      --text: #e6e6e6;
      --muted: #9aa4b2;
      --accent: #6ab0ff;
      --accent-2: #ffd166;
      --ok: #4cd3a8;
      --danger: #ff6b6b;
      --outline: #222842;
      --sidebar-w: 320px;
      /* 80s pixel theme accents */
      --crt-grid-1: #101935;
      --crt-grid-2: #0b1430;
      --crt-border: #2b3a84;
      --crt-neon: #6af2ff;
      --crt-neon-2: #ff6ad5;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; height: 100%; background: var(--bg); color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif; }
    #app { display: grid; grid-template-columns: var(--sidebar-w) 1fr; height: 100vh; width: 100vw; overflow: hidden; }
    /* --- 80s Pixel Panel --- */
    aside {
      position: relative;
      padding: 14px;
      overflow-y: auto;
      /* Keep layout stable when scrollbar appears */
      scrollbar-gutter: stable both-edges;
      background:
        repeating-linear-gradient(
          to bottom,
          var(--crt-grid-1) 0px,
          var(--crt-grid-1) 3px,
          var(--crt-grid-2) 3px,
          var(--crt-grid-2) 6px
        );
      border-right: 0;
      box-shadow:
        inset 0 0 0 2px var(--crt-border), /* chunky inner border */
        inset 0 0 0 4px #0a0f2a,           /* bezel */
        0 0 0 1px #000,                   /* outer hairline */
        0 0 24px rgba(106, 242, 255, 0.08); /* glow */
      image-rendering: pixelated;
      -webkit-font-smoothing: none; /* make text a bit more aliased */
      font-family: "Lucida Console", "Monaco", "Courier New", monospace;
      letter-spacing: 0.3px;
    }
    /* Pixel-styled scrollbars */
    aside { scrollbar-width: thin; scrollbar-color: var(--crt-neon) transparent; }
    aside::-webkit-scrollbar { width: 8px; height: 8px; }
    aside::-webkit-scrollbar-track { background: transparent; }
    aside::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(106,242,255,0.85), rgba(255,106,213,0.85));
      box-shadow: inset 0 0 0 2px #0a0f2a, 0 0 10px rgba(106,242,255,0.25);
    }
    aside::-webkit-scrollbar-corner { background: transparent; }
    /* subtle scanline sweep */
    aside::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(
        to bottom,
        transparent 0%,
        rgba(255,255,255,0.04) 48%,
        transparent 100%
      );
      mix-blend-mode: soft-light;
      pointer-events: none;
      animation: crtSweep 5s linear infinite;
      opacity: 0.35;
    }
    @keyframes crtSweep {
      0% { transform: translateY(-100%); }
      100% { transform: translateY(100%); }
    }

    h1 { font-size: 14px; margin: 0 0 10px; display: flex; align-items: center; gap: 8px; text-transform: uppercase; letter-spacing: 1px; color: var(--accent-2); text-shadow: 1px 1px 0 #000, 0 0 6px rgba(255, 209, 102, 0.35); }
    .brand-dot { width: 8px; height: 8px; background: var(--crt-neon); box-shadow: 0 0 6px var(--crt-neon), 0 0 12px rgba(106,242,255,0.6); }
    section { margin-bottom: 14px; padding-bottom: 12px; border-bottom: 1px dashed var(--outline); }
    section:last-child { border-bottom: none; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 10px; margin: 6px 0; }
    .row label { font-size: 11px; color: var(--muted); flex: 1; text-transform: uppercase; letter-spacing: 0.5px; }
    .row .value { font-variant-numeric: tabular-nums; color: var(--crt-neon); min-width: 56px; text-align: right; font-size: 11px; text-shadow: 0 0 6px rgba(106,242,255,0.4); }
    .radio-group { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }
    .radio-group input { display: none; }
    .radio-group label {
      display: inline-flex; align-items: center; justify-content: center; gap: 6px;
      padding: 6px 4px; cursor: pointer; font-size: 11px; text-transform: uppercase;
      background: #0d1020; color: var(--text);
      border: 0; border-radius: 0; box-shadow:
        inset 0 0 0 2px var(--crt-border),
        inset 0 0 0 4px #0a0f2a,
        0 0 0 1px #000;
    }
    .radio-group input:checked + label {
      background: #0e1a35;
      box-shadow:
        inset 0 0 0 2px var(--crt-neon),
        inset 0 0 0 4px #0a0f2a,
        0 0 12px rgba(106, 242, 255, 0.35);
      color: var(--crt-neon);
      text-shadow: 0 0 6px rgba(106,242,255,0.5);
    }
    input[type="range"], select, button { width: 100%; accent-color: var(--crt-neon); }
    select, button, input[type="number"], input[type="text"] {
      background: #0d1020; color: var(--text);
      border: 0; border-radius: 0; padding: 6px 8px; font-size: 11px;
      box-shadow: inset 0 0 0 2px var(--crt-border), inset 0 0 0 4px #0a0f2a, 0 0 0 1px #000;
      text-transform: uppercase; letter-spacing: 0.5px;
    }
    button { cursor: pointer; color: var(--crt-neon); text-shadow: 0 0 6px rgba(106,242,255,0.45); }
    /* --- Tooltip (pixel/CRT style) --- */
    .has-tip { position: relative; cursor: help; }
    .has-tip::before {
      content: "?";
      display: inline-block; margin-left: 6px; width: 14px; height: 14px; line-height: 14px; text-align: center;
      font-size: 10px; color: var(--crt-neon); background: #0d1020; vertical-align: middle; transform: translateY(-1px);
      box-shadow: inset 0 0 0 2px var(--crt-border), inset 0 0 0 4px #0a0f2a, 0 0 0 1px #000;
    }
    .has-tip::after {
      content: attr(data-tip);
      position: absolute; left: 0; top: 100%; transform: translateY(6px);
      background: rgba(20,22,35,0.95); color: #e9f1ff; padding: 6px 8px; font-size: 10px;
      text-transform: none; letter-spacing: 0.2px; max-width: 260px; white-space: normal; z-index: 3;
      box-shadow: inset 0 0 0 2px var(--crt-border), inset 0 0 0 4px #0a0f2a, 0 0 12px rgba(106,242,255,0.2);
      display: none;
    }
    .has-tip:hover::after, .has-tip:focus-visible::after { display: block; }
    .btn-row { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
    .btn-row-2 { display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; }
    .warn { border-color: #633; color: #ffdede; }
    .small { font-size: 10px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.4px; }
    .legend { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .dot { width: 10px; height: 10px; display: inline-block; border-radius: 0; box-shadow: 0 0 8px rgba(255,255,255,0.15); }
    .gas { background: #6ab0ff; box-shadow: 0 0 8px rgba(106,176,255,0.6); }
    .rock { background: #caa36d; box-shadow: 0 0 8px rgba(202,163,109,0.5); }
    .ice { background: #9fefff; box-shadow: 0 0 8px rgba(159,239,255,0.6); }
    .eraser { background: #151515; box-shadow: inset 0 0 0 2px #555; }
    canvas { 
      display: block; width: 100%; height: 100%; 
      background: linear-gradient(45deg, #020304, #05060a, #0a0f1a); 
      image-rendering: auto;
      /* Enhanced visual quality */
      image-rendering: -webkit-optimize-contrast;
      image-rendering: optimize-contrast;
      -ms-interpolation-mode: nearest-neighbor;
    }
    #hud { position: absolute; top: 8px; right: 8px; background: rgba(10,12,20,0.5); border: 1px solid var(--outline); border-radius: 8px; padding: 6px 8px; font-size: 12px; color: #d6dee9; pointer-events: none; backdrop-filter: blur(4px); }
    #tooltip { position: absolute; pointer-events: none; z-index: 2; background: rgba(20,22,35,0.88); border: 1px solid var(--outline); border-radius: 6px; padding: 6px 8px; font-size: 12px; color: #e9f1ff; transform: translate(12px, 12px); min-width: 160px; max-width: 260px; display: none; }
    .kbd { display: inline-block; padding: 1px 5px; border: 0; border-radius: 0; background: #0d1020; font-size: 10px; color: var(--crt-neon); box-shadow: inset 0 0 0 2px var(--crt-border), inset 0 0 0 4px #0a0f2a, 0 0 0 1px #000; text-transform: uppercase; letter-spacing: 0.4px; }
    /* Help Modal */
    #help-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 999; }
    #help-modal { width: min(780px, 92vw); max-height: 82vh; overflow: auto; padding: 14px; background: linear-gradient(180deg, var(--panel), var(--panel-2)); color: var(--text);
      border: 0; box-shadow: inset 0 0 0 2px var(--crt-border), inset 0 0 0 4px #0a0f2a, 0 0 0 1px #000, 0 10px 30px rgba(0,0,0,0.5); }
    .modal-close { background: #0d1020; color: var(--text); border: 0; border-radius: 0; padding: 6px 8px; box-shadow: inset 0 0 0 2px var(--crt-border), inset 0 0 0 4px #0a0f2a, 0 0 0 1px #000; cursor: pointer; }
    @media (max-width: 860px) { :root { --sidebar-w: 280px; } .radio-group { grid-template-columns: repeat(2, 1fr); } }
  </style>
  </head>
  <body>
    <div id="app">
      <aside>
        <h1><span class="brand-dot"></span> Solar System Sandbox</h1>

        <section>
          <div class="btn-row-2">
            <button id="openHelp">Help / Basics</button>
          </div>
        </section>

        <section>
          <div class="legend" aria-hidden="true">
            <span class="dot gas"></span> Gas
            <span class="dot rock"></span> Rock/Dust
            <span class="dot ice"></span> Ice
            <span class="dot eraser"></span> Eraser
          </div>
        </section>

        <section>
          <div class="row"><label>Tool</label></div>
          <div class="radio-group" role="radiogroup" aria-label="Tools">
            <input type="radio" name="tool" id="tool-gas" value="gas" checked>
            <label for="tool-gas" title="Gas (H/He)">Gas</label>
            <input type="radio" name="tool" id="tool-rock" value="rock">
            <label for="tool-rock" title="Rock/Dust">Rock</label>
            <input type="radio" name="tool" id="tool-ice" value="ice">
            <label for="tool-ice" title="Ice">Ice</label>
            <input type="radio" name="tool" id="tool-eraser" value="eraser">
            <label for="tool-eraser" title="Eraser">Erase</label>
          </div>

          <div class="row"><label for="brushSize" class="has-tip" data-tip="Diameter of the paint brush in pixels.">Brush size</label><div class="value" id="brushSizeVal"></div></div>
          <input id="brushSize" type="range" min="2" max="80" step="1" value="18">

          <div class="row"><label for="massPerDot" class="has-tip" data-tip="Mass added by each spawned dot; larger = heavier bodies.">Mass per dot</label><div class="value" id="massPerDotVal"></div></div>
          <input id="massPerDot" type="range" min="0.5" max="50" step="0.5" value="4">

          <div class="row"><label for="spawnRate" class="has-tip" data-tip="Dots spawned per second while painting.">Spawn rate (dots/s)</label><div class="value" id="spawnRateVal"></div></div>
          <input id="spawnRate" type="range" min="4" max="200" step="2" value="60">

          <div class="small">Tip: Hold <span class="kbd">V</span> while painting to throw with velocity.</div>
        </section>

        <section>
          <div class="row"><label for="gravity" class="has-tip" data-tip="Strength of gravitational attraction between bodies.">Gravity G</label><div class="value" id="gravityVal"></div></div>
          <input id="gravity" type="range" min="0.01" max="2.0" step="0.01" value="0.28">

          <div class="row"><label for="timeScale" class="has-tip" data-tip="Global time multiplier for the simulation.">Time scale</label><div class="value" id="timeScaleVal"></div></div>
          <input id="timeScale" type="range" min="0.1" max="3.0" step="0.1" value="1.8">

          <div class="row"><label for="speedBoost" class="has-tip" data-tip="Extra speed multiplier; stacks with Time scale.">Speed</label><div class="value" id="speedBoostVal"></div></div>
          <input id="speedBoost" type="range" min="0.2" max="6.0" step="0.1" value="1.0">

          <div class="row"><label for="softening" class="has-tip" data-tip="Softens gravity at short distances to avoid singularities.">Softening</label><div class="value" id="softeningVal"></div></div>
          <input id="softening" type="range" min="2" max="60" step="1" value="18">

          <div class="row"><label for="starThreshold" class="has-tip" data-tip="Mass needed (with enough gas) to ignite into a star.">Star mass threshold</label><div class="value" id="starThresholdVal"></div></div>
          <input id="starThreshold" type="range" min="200" max="5000" step="10" value="1400">

          <div class="row"><label for="planetThreshold" class="has-tip" data-tip="Mass needed to count as a planet (below star threshold).">Planet mass threshold</label><div class="value" id="planetThresholdVal"></div></div>
          <input id="planetThreshold" type="range" min="20" max="400" step="5" value="60">

          <div class="row"><label for="igniteFrac" class="has-tip" data-tip="Minimum gas fraction required for a massive body to become a star.">Ignite gas fraction</label><div class="value" id="igniteFracVal"></div></div>
          <input id="igniteFrac" type="range" min="0.4" max="0.95" step="0.01" value="0.7">
        </section>

        <section>
          <div class="row"><label for="trails">Trails</label>
            <select id="trails"><option value="off">Off</option><option value="short" selected>Short</option><option value="long">Long</option></select></div>
          <div class="row"><label for="vectors">Vectors</label>
            <select id="vectors"><option value="off" selected>Off</option><option value="vel">Velocity</option><option value="acc">Acceleration</option></select></div>
          <div class="row"><label for="edge">Edge behavior</label>
            <select id="edge"><option value="wrap" selected>Wrap</option><option value="bounce">Bounce</option><option value="void">Void</option></select></div>
          <div class="row"><label for="orbitAssist">Orbit assist</label>
            <input id="orbitAssist" type="checkbox" checked></div>
          <div class="row"><label for="orbitGuide">Orbit guide</label>
            <input id="orbitGuide" type="checkbox" checked></div>
          <div class="small" style="margin-top:6px;">
            Tip: Aim for <strong>v/v_circ ≈ 1.0</strong> for near-circular orbits; <strong>&lt; 1</strong> is suborbital (falls inward), <strong>&gt; 1</strong> gives elliptical/escape. Use <span class="kbd">V</span> to tweak eccentricity.
          </div>
        </section>

        <section>
          <div class="btn-row">
            <button id="seedDemo">Seed Demo</button>
            <button id="randomBelt">Random Belt</button>
            <button id="clear" class="warn">Clear</button>
            <button id="presetSystem">Preset System</button>
            <button id="seedSolarSystem">Solar System</button>
          </div>
          <div class="btn-row-2" style="margin-top:6px;">
            <button id="togglePause">Pause</button>
            <button id="centerView">Center View</button>
          </div>
        </section>

        <section>
          <div class="btn-row-2">
            <button id="save">Save</button>
            <button id="load">Load</button>
          </div>
          <div class="small" style="margin-top:6px;">Saves to localStorage. Includes scene and current config.</div>
        </section>

        <section class="small">
          Shortcuts: <span class="kbd">Space</span> Pause, <span class="kbd">1</span> Gas, <span class="kbd">2</span> Rock, <span class="kbd">3</span> Ice
          <div id="capInfo" style="margin-top:6px;">Cap: 0 / 0 bodies</div>
        </section>
      </aside>

      <div style="position: relative;">
        <canvas id="canvas"></canvas>
        <div id="hud"></div>
        <div id="tooltip" role="tooltip" aria-hidden="true"></div>
      </div>
    </div>

    <!-- Help Modal -->
    <div id="help-modal-overlay" aria-hidden="true">
      <div id="help-modal" role="dialog" aria-modal="true" aria-labelledby="help-title">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:8px;">
          <h2 id="help-title" style="margin:0; font-size:16px; color: var(--accent-2);">Basics & Controls</h2>
          <button id="help-close" class="modal-close" aria-label="Close">✕</button>
        </div>
        <div class="small" style="line-height:1.4;">
          <p><strong>Paint</strong>: Click + drag to add matter. Select <em>Gas</em>, <em>Rock</em>, or <em>Ice</em>. Use <span class="kbd">Eraser</span> to remove.</p>
          <p><strong>Throw</strong>: Hold <span class="kbd">V</span> while painting to throw dots with velocity (based on mouse movement).</p>
          <p><strong>Pause</strong>: <span class="kbd">Space</span>. Tools: <span class="kbd">1</span> Gas, <span class="kbd">2</span> Rock, <span class="kbd">3</span> Ice.</p>
          <p><strong>Keep a planet in orbit</strong>: Aim for <span class="kbd">v/v_circ ≈ 1.0</span> using the orbit guide arrow. Move the cursor around the star: the arrow shows the direction and speed for a circular orbit at your cursor radius. When painting with <span class="kbd">V</span>, throw roughly along that arrow. In the tooltip you’ll see <em>v/v_circ</em>; values near 1.0 are near-circular, lower falls inward, higher gives elliptical/escape.</p>

          <hr style="border:0; border-top:1px dashed var(--outline); margin:10px 0;">

          <p style="margin:6px 0 4px;"><strong>Sliders</strong></p>
          <ul>
            <li><strong>Brush size</strong>: Diameter of the paint brush (px).</li>
            <li><strong>Mass per dot</strong>: Mass added by each spawned dot.</li>
            <li><strong>Spawn rate</strong>: Dots spawned per second while painting.</li>
            <li><strong>Gravity G</strong>: Strength of gravitational attraction between bodies.</li>
            <li><strong>Time scale</strong>: Multiplies simulated time progression (keeps integrator steps stable).</li>
            <li><strong>Speed</strong>: Additional speed multiplier; stacks with Time scale.</li>
            <li><strong>Softening</strong>: Softens gravity at short distances to avoid singularities.</li>
            <li><strong>Star mass threshold</strong>: Minimum mass (with enough gas) to ignite into a star.</li>
            <li><strong>Planet mass threshold</strong>: Mass needed to count as a planet.</li>
            <li><strong>Ignite gas fraction</strong>: Minimum gas fraction for a massive body to become a star.</li>
          </ul>

          <p style="margin:6px 0 4px;"><strong>Options</strong></p>
          <ul>
            <li><strong>Trails</strong>: Off/Short/Long fading trails behind bodies.</li>
            <li><strong>Vectors</strong>: Show velocity or acceleration arrows.</li>
            <li><strong>Edge behavior</strong>: Wrap, Bounce, or Void (remove when leaving bounds).</li>
            <li><strong>Orbit assist</strong>: While painting, biases the initial velocity toward circular orbit.</li>
            <li><strong>Orbit guide</strong>: Shows arrow with circular speed at the cursor radius.</li>
          </ul>

          <p class="small">Tip: Start with a star (use the Demo or Solar System preset), then paint a small rocky planet. Use the guide arrow and <span class="kbd">V</span> throw to match <em>v/v_circ</em> ≈ 1.0.</p>
        </div>
      </div>
    </div>

    <script>
      // ===============================
      // Config
      // ===============================
      // Purpose: Centralize all tweakable constants and defaults.
      const CONFIG = {
        // Physics
        // Gravitational constant (computed for Solar System seeding)
        // In general sandbox mode, this is user-tweakable.
        G: 0.28,
        softening: 18,           // Softening (pixels) (overridden in Solar System for accuracy)
        timeScale: 1.0,          // Global time multiplier
        dtTarget: 1/60,          // Target timestep (s)
        maxDt: 1/20,             // Clamp huge frame gaps
        physicsHz: 180,          // Fixed physics rate for smoothness
        gravityCutoff: 1e9,      // Large cutoff so full-system gravity remains accurate

        // Densities (relative units)
        density: { gas: 0.7, rock: 3.2, ice: 1.2 },
        radiusScale: 2.2,        // Visual radius scale

        // Classification
        starMassThreshold: 1400,
        planetMassThreshold: 60,
        igniteGasFraction: 0.7,

        // Rendering
        trailLength: { off: 0, short: 24, long: 60 },
        fadeAlpha: { off: 1.0, short: 0.16, long: 0.06 }, // background fade
        trailAlpha: 0.4,
        vectorScaleVel: 0.8,
        vectorScaleAcc: 120,
        orbitGuideScale: 18,     // pixels per (px/s) for orbit guide arrow
        speedBoost: 1.0,         // Additional speed multiplier from Speed slider
        minDrawRadius: 1.2,
        backgroundStars: 220,
        // Spatial scale
        pxPerAU: null,          // computed when seeding Solar System

        // Pixel art style
        pixelArt: false, // disable pixelation for sharper rendering
        pixelSize: 1,

        // Body limits & collisions
        maxBodies: 800,
        gridSize: 48,

        // Painting
        brushSize: 18,
        massPerDot: 4,
        spawnRate: 60,
        throwScale: 2.0,  // px of mouse/frame to velocity

        // Edges
        edgeBehavior: 'wrap', // wrap | bounce | void

        // Picking
        pickRadius: 14,

        // Save
        saveKey: 'solar-sandbox-state-v1',

        // Time units
        // When Solar System mode is active, simulation time is in years.
        // yearsPerSecond maps real seconds -> simulation years (scaled by Time scale & Speed).
        yearsPerSecond: 0.0,

        // Softening
        // Base Plummer softening in pixels and a per-pair scale relative to object radii
        softeningK: 0.25,

        // Collisions
        // Only merge if relative speed is below this factor of escape velocity at contact
        mergeVEscapeFactor: 0.9,

        // Adaptive time step (Kick-Drift-Kick)
        adaptive: {
          eta: 0.06,         // safety factor for dynamical timescale
          dtMin: 1/5000,     // minimum step in sim time units (sec or years depending on mode)
          dtMax: 1/120,      // maximum step in sim time units
          smoothChange: 2.0  // limit dt change factor per sub-step
        }
      };

      // ===============================
      // State
      // ===============================
      // Purpose: Hold bodies, UI selections, and runtime variables.
      const State = {
        bodies: [],
        nextId: 1,
        paused: false,
        trails: 'short',
        vectors: 'off', // off|vel|acc
        tool: 'gas',
        orbitAssist: true,
        orbitGuide: true,
        canvas: null,
        ctx: null,
        w: 0, h: 0, dpr: 1,
        mouse: { x:0, y:0, sx:0, sy:0, down:false, lastX:0, lastY:0, lastSX:0, lastSY:0, throwing:false },
        lastTime: performance.now()/1000,
        spawnAccum: 0,
        bgStars: [],
        fps: 0, fpsAccum: 0, fpsFrames: 0,
        hoverId: null,
        hash: new Map(),
        accum: 0,
        interpAlpha: 0,
        // Pixelation buffer
        pxCanvas: null,
        pxCtx: null,

        // Modes/units
        solarMode: false,     // true when Solar System preset is active (time unit = years)

        // Adaptive stepping diagnostics
        minPairTau: Infinity, // estimated minimum dynamical timescale from last force eval
        lastAdaptiveDt: 1/180,
        lastDt: 1/180,

        // Invariants
        invariants: null,     // latest computed {E,Lz,Px,Py}
        invariants0: null,    // baseline at start/reset
        invTimer: 0           // throttle invariant computations
      };

      // ===============================
      // UI Bindings
      // ===============================
      // Purpose: Wire DOM controls to CONFIG/State and update labels.
      function bindUI() {
        const byId = id => document.getElementById(id);
        const setVal = (id, v) => byId(id).textContent = v;

        for (const name of ['gas','rock','ice','eraser']) {
          const input = byId(`tool-${name}`);
          input.addEventListener('change', () => { if (input.checked) State.tool = name; });
        }

        const sliders = [
          ['brushSize', 'brushSizeVal', 'px', v => CONFIG.brushSize = +v],
          ['massPerDot', 'massPerDotVal', '', v => CONFIG.massPerDot = +v],
          ['spawnRate', 'spawnRateVal', '/s', v => CONFIG.spawnRate = +v],
          ['gravity', 'gravityVal', '', v => CONFIG.G = +v],
          ['timeScale', 'timeScaleVal', 'x', v => CONFIG.timeScale = +v],
          ['speedBoost', 'speedBoostVal', 'x', v => CONFIG.speedBoost = +v],
          ['softening', 'softeningVal', 'px', v => CONFIG.softening = +v],
          ['starThreshold', 'starThresholdVal', '', v => CONFIG.starMassThreshold = +v],
          ['planetThreshold', 'planetThresholdVal', '', v => CONFIG.planetMassThreshold = +v],
          ['igniteFrac', 'igniteFracVal', '', v => CONFIG.igniteGasFraction = +v],
        ];
        for (const [id, label, suffix, on] of sliders) {
          const el = byId(id);
          const update = () => { on(el.value); setVal(label, el.value + ' ' + suffix); updateCapInfo(); };
          el.addEventListener('input', update); update();
        }

        const trails = byId('trails');
        trails.addEventListener('change', () => { State.trails = trails.value; });
        State.trails = trails.value;

        const vectors = byId('vectors');
        vectors.addEventListener('change', () => { State.vectors = vectors.value; });
        State.vectors = vectors.value;

        const edge = byId('edge');
        edge.addEventListener('change', () => { CONFIG.edgeBehavior = edge.value; });
        CONFIG.edgeBehavior = edge.value;

        // Orbit Assist
        const orbitAssist = byId('orbitAssist');
        State.orbitAssist = orbitAssist.checked;
        orbitAssist.addEventListener('change', () => { State.orbitAssist = orbitAssist.checked; });

        // Orbit Guide
        const orbitGuide = byId('orbitGuide');
        State.orbitGuide = orbitGuide.checked;
        orbitGuide.addEventListener('change', () => { State.orbitGuide = orbitGuide.checked; });

        byId('seedDemo').addEventListener('click', seedDemo);
        byId('randomBelt').addEventListener('click', seedRandomBelt);
        byId('presetSystem').addEventListener('click', seedPresetSystem);
        const solarBtn = byId('seedSolarSystem'); if (solarBtn) solarBtn.addEventListener('click', seedSolarSystem);
        byId('clear').addEventListener('click', clearBodies);
        byId('togglePause').addEventListener('click', () => {
          State.paused = !State.paused; byId('togglePause').textContent = State.paused ? 'Resume' : 'Pause';
        });
        byId('centerView').addEventListener('click', () => { centerView(); flashHUD('Centered'); });
        byId('save').addEventListener('click', saveToLocalStorage);
        byId('load').addEventListener('click', loadFromLocalStorage);

        updateCapInfo();

        // Help modal events
        const openHelp = byId('openHelp');
        const modalOverlay = byId('help-modal-overlay');
        const closeHelp = byId('help-close');
        function showHelp(){ modalOverlay.style.display = 'flex'; modalOverlay.setAttribute('aria-hidden','false'); }
        function hideHelp(){ modalOverlay.style.display = 'none'; modalOverlay.setAttribute('aria-hidden','true'); }
        if (openHelp) openHelp.addEventListener('click', showHelp);
        if (closeHelp) closeHelp.addEventListener('click', hideHelp);
        if (modalOverlay) modalOverlay.addEventListener('click', (e)=>{ if (e.target === modalOverlay) hideHelp(); });
        window.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') hideHelp(); });
      }

      function centerView(){
        const star = largestStar();
        const cx = State.w*0.5, cy = State.h*0.5;
        if (!star){
          State.view.x = 0; State.view.y = 0; State.view.scale = 1;
          return;
        }
        // Keep current scale, pan to center the star
        const v = State.view; const s = v.scale;
        v.x = cx - star.x * s;
        v.y = cy - star.y * s;
      }

      function updateCapInfo() {
        const el = document.getElementById('capInfo');
        el.textContent = `Cap: ${State.bodies.length} / ${CONFIG.maxBodies} bodies`;
      }

      // ===============================
      // Canvas Setup
      // ===============================
      function initCanvas() {
        State.canvas = document.getElementById('canvas');
        State.ctx = State.canvas.getContext('2d');
        
        // Enhanced rendering settings for better visual quality
        State.ctx.imageSmoothingEnabled = true;
        State.ctx.imageSmoothingQuality = 'high';
        State.ctx.lineCap = 'round';
        State.ctx.lineJoin = 'round';
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        // Background stars
        State.bgStars = Array.from({length: CONFIG.backgroundStars}, () => ({
          x: Math.random(), y: Math.random(), r: Math.random()*1.2+0.3, a: Math.random()*0.5+0.2
        }));

        // Offscreen low-res canvas for pixelation pass
        State.pxCanvas = document.createElement('canvas');
        State.pxCtx = State.pxCanvas.getContext('2d');
        if (State.pxCtx) State.pxCtx.imageSmoothingEnabled = false;
        // Reset view (pan/zoom)
        State.view = { scale: 1, x: 0, y: 0 };
      }

      function resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
        const rect = State.canvas.getBoundingClientRect();
        State.w = Math.max(1, Math.floor(rect.width * dpr));
        State.h = Math.max(1, Math.floor(rect.height * dpr));
        State.dpr = dpr;
        State.canvas.width = State.w;
        State.canvas.height = State.h;
        // Resize pixel buffer
        const ps = Math.max(1, Math.floor(CONFIG.pixelSize || 1));
        if (State.pxCanvas) {
          State.pxCanvas.width = Math.max(1, Math.floor(State.w / ps));
          State.pxCanvas.height = Math.max(1, Math.floor(State.h / ps));
        }
      }

      // ===============================
      // Factories & Utilities
      // ===============================
      // Purpose: Create bodies and compute derived parameters.
      function createBody(x, y, mass, comp, vx=0, vy=0) {
        const sum = comp.gas + comp.rock + comp.ice || 1;
        const mix = { gas: comp.gas/sum, rock: comp.rock/sum, ice: comp.ice/sum };
        const density = mixDensity(mix);
        const radius = radiusFromMassDensity(mass, density);
        return {
          id: State.nextId++, x, y, vx, vy, ax:0, ay:0,
          mass, radius, density, comp: mix,
          type: classify(mass, mix.gas),
          trail: [],
        };
      }

      // Computes effective density via harmonic mean of component densities.
      function mixDensity(frac) {
        const d = CONFIG.density;
        const inv = (frac.gas/d.gas) + (frac.rock/d.rock) + (frac.ice/d.ice);
        return inv > 0 ? 1/inv : d.rock;
      }

      // Converts mass and density to radius (r ∝ cbrt(mass/density)).
      function radiusFromMassDensity(mass, density) {
        const r = CONFIG.radiusScale * Math.cbrt(Math.max(mass/Math.max(density,1e-6), 0));
        return Math.max(r, CONFIG.minDrawRadius);
      }

      // Classifies body type based on mass thresholds and gas fraction.
      function classify(mass, gasFrac) {
        if (mass >= CONFIG.starMassThreshold && gasFrac >= CONFIG.igniteGasFraction) return 'star';
        if (mass >= CONFIG.planetMassThreshold && mass < CONFIG.starMassThreshold) return 'planet';
        return 'debris';
      }

      // Returns circular orbit speed around a central mass at radius r: v = sqrt(G M / r)
      function circularSpeed(G, M, r) {
        return r > 0 ? Math.sqrt(G * M / r) : 0;
      }

      // Planet subtype refinement by dominant composition.
      function planetSubtype(comp) {
        if (comp.gas >= 0.55) return 'gas-giant';
        if (comp.ice >= 0.55) return 'ice-giant';
        return 'terrestrial';
      }

      // Maps star mass to approximate temperature and color.
      function starColor(mass) {
        const m0 = CONFIG.starMassThreshold;
        const t = Math.min(1, Math.max(0, (mass - m0) / (m0*4))); // normalize
        // gradient: red -> yellow -> white -> blue-white
        const stops = [
          {r:255,g:120,b:80}, {r:255,g:210,b:110}, {r:245,g:245,b:255}, {r:200,g:220,b:255}
        ];
        const seg = t * (stops.length - 1);
        const i = Math.floor(seg);
        const f = seg - i;
        const a = stops[i], b = stops[Math.min(i+1, stops.length-1)];
        return { r: Math.round(a.r + (b.r-a.r)*f), g: Math.round(a.g + (b.g-a.g)*f), b: Math.round(a.b + (b.b-a.b)*f), temp: 3000 + 7000*t };
      }

      function withAlpha(rgb, a) { return `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`; }
      function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
      function getTimeScale() { return CONFIG.timeScale * CONFIG.speedBoost; }
      function isSolarMode(){ return State.solarMode && !!CONFIG.pxPerAU; }

      // ===== Visual helpers (colors, RNG) =====
      // Purpose: Provide small utilities for procedural shading without external deps.
      function shade(rgb, amt) {
        // Brightness shift: amt in [-1,1]
        return {
          r: clamp(Math.round(rgb.r + amt * 255), 0, 255),
          g: clamp(Math.round(rgb.g + amt * 255), 0, 255),
          b: clamp(Math.round(rgb.b + amt * 255), 0, 255)
        };
      }
      function lerpColor(a,b,t){ return { r:Math.round(a.r+(b.r-a.r)*t), g:Math.round(a.g+(b.g-a.g)*t), b:Math.round(a.b+(b.b-a.b)*t) }; }
      function rgbStr(c){ return `rgb(${c.r},${c.g},${c.b})`; }
      function seededRng(seed){
        // Simple LCG for deterministic per-body decoration
        let s = (seed >>> 0) || 1; return () => { s = (1664525*s + 1013904223) >>> 0; return (s & 0xffffff)/0x1000000; };
      }

      // Dominant composition and palette selection
      function dominantComp(comp){
        if (comp.gas >= comp.rock && comp.gas >= comp.ice) return 'gas';
        if (comp.ice >= comp.gas && comp.ice >= comp.rock) return 'ice';
        return 'rock';
      }
      function planetPalette(body){
        const dom = dominantComp(body.comp);
        if (dom === 'gas') return { base:{r:202,g:190,b:160}, light:{r:230,g:220,b:190}, dark:{r:150,g:140,b:120}, atm:{r:170,g:200,b:255} };
        if (dom === 'ice') return { base:{r:185,g:220,b:240}, light:{r:235,g:250,b:255}, dark:{r:120,g:150,b:170}, atm:{r:190,g:235,b:255} };
        return { base:{r:176,g:146,b:120}, light:{r:220,g:200,b:180}, dark:{r:110,g:95,b:85}, atm:{r:230,g:210,b:190} };
      }
      function nearestStarTo(body){
        let best=null, d2Min=Infinity;
        for (const b of State.bodies) if (b.type==='star'){
          const dx=b.x-body.x, dy=b.y-body.y; const d2=dx*dx+dy*dy; if (d2<d2Min){ d2Min=d2; best=b; }
        }
        return best;
      }

      // ===============================
      // Input & Interaction
      // ===============================
      // Purpose: Painting, erasing, throwing, keyboard shortcuts, picking.
      function initInput() {
        const c = State.canvas;
        c.addEventListener('mousedown', e => { State.mouse.down = true; updateMouse(e); });
        window.addEventListener('mouseup', () => { State.mouse.down = false; });
        c.addEventListener('mousemove', e => { updateMouse(e); });
        c.addEventListener('mouseleave', () => { State.mouse.down = false; });

        // Zoom with wheel (zoom around cursor)
        c.addEventListener('wheel', e => {
          e.preventDefault();
          const v = State.view;
          const old = v.scale;
          const factor = Math.pow(1.1, -Math.sign(e.deltaY));
          let next = old * factor;
          next = Math.max(0.25, Math.min(6, next));
          const mx = (State.mouse.sx || 0), my = (State.mouse.sy || 0);
          const wx = (mx - v.x)/old, wy = (my - v.y)/old;
          v.scale = next;
          v.x = mx - wx * next;
          v.y = my - wy * next;
        }, { passive: false });

        window.addEventListener('keydown', e => {
          if (e.code === 'Space') { e.preventDefault(); State.paused = !State.paused; document.getElementById('togglePause').textContent = State.paused ? 'Resume' : 'Pause'; }
          if (e.key === '1') document.getElementById('tool-gas').checked = true, State.tool = 'gas';
          if (e.key === '2') document.getElementById('tool-rock').checked = true, State.tool = 'rock';
          if (e.key === '3') document.getElementById('tool-ice').checked = true, State.tool = 'ice';
          if (e.key === 'v' || e.key === 'V') State.mouse.throwing = true;
        });
        window.addEventListener('keyup', e => { if (e.key === 'v' || e.key === 'V') State.mouse.throwing = false; });
      }

      function mousePos(e) { const r = State.canvas.getBoundingClientRect(); return { x: (e.clientX - r.left) * State.dpr, y: (e.clientY - r.top) * State.dpr }; }
      function screenToWorld(sx, sy){ const v=State.view; return { x: (sx - v.x)/v.scale, y: (sy - v.y)/v.scale }; }
      function worldToScreen(x, y){ const v=State.view; return { sx: x*v.scale + v.x, sy: y*v.scale + v.y }; }
      function updateMouse(e) {
        const p = mousePos(e);
        State.mouse.lastSX = State.mouse.sx; State.mouse.lastSY = State.mouse.sy;
        State.mouse.sx = p.x; State.mouse.sy = p.y;
        const w = screenToWorld(p.x, p.y);
        State.mouse.lastX = State.mouse.x; State.mouse.lastY = State.mouse.y;
        State.mouse.x = w.x; State.mouse.y = w.y;
      }

      // ===============================
      // Physics (Gravity & Integration)
      // ===============================
      // Purpose: Compute accelerations and advance system with leapfrog.
      function perPairSoftening2(A, B){
        const base = CONFIG.softening || 0;
        const k = CONFIG.softeningK || 0;
        const eps = base + k * ((A.radius||0) + (B.radius||0));
        return eps * eps;
      }

      function computeAccelerations(bodies) {
        const n = bodies.length;
        for (let i=0;i<n;i++){ bodies[i].ax=0; bodies[i].ay=0; }
        const cutoff2 = CONFIG.gravityCutoff * CONFIG.gravityCutoff;
        let minTau = Infinity;
        for (let i=0;i<n;i++){
          const bi=bodies[i];
          for (let j=i+1;j<n;j++){
            const bj=bodies[j];
            let dx=bj.x-bi.x, dy=bj.y-bi.y;
            const r2=dx*dx+dy*dy; if (r2>cutoff2) continue;
            const eps2 = perPairSoftening2(bi, bj);
            const invR=1/Math.sqrt(r2+eps2); const invR3=invR*invR*invR;
            const f=CONFIG.G*invR3; const fx=dx*f, fy=dy*f;
            // Acceleration on i from j: a_i += G * m_j * r_hat / r^2
            bi.ax += fx*bj.mass; bi.ay += fy*bj.mass;
            // Equal and opposite on j from i
            bj.ax -= fx*bi.mass; bj.ay -= fy*bi.mass;

            // Estimate pair dynamical timescale tau ~ sqrt(r^3 / (G*(m_i+m_j)))
            const rEff = 1/invR; // = sqrt(r2+eps2)
            const muPair = CONFIG.G * (bi.mass + bj.mass);
            if (muPair > 0){
              const tau = Math.sqrt((rEff*rEff*rEff) / (muPair + 1e-18));
              if (tau < minTau) minTau = tau;
            }
          }
        }
        State.minPairTau = (minTau===Infinity? State.minPairTau : minTau);
      }

      function integrate(bodies, dt) {
        // Leapfrog (Kick-Drift-Kick): half velocity kick, full drift, recompute a, half kick.
        const sdt = dt; // dt is in simulation seconds (already scaled)
        const half = 0.5 * sdt;
        // Kick half-step
        for (let b of bodies) { b.vx += b.ax * half; b.vy += b.ay * half; }
        // Drift full-step
        for (let b of bodies) { b.x += b.vx * sdt; b.y += b.vy * sdt; }
        // Recompute accelerations at new positions
        computeAccelerations(bodies);
        // Kick half-step to complete
        for (let b of bodies) { b.vx += b.ax * half; b.vy += b.ay * half; }
      }

      // ===============================
      // Edges
      // ===============================
      // Purpose: Apply wrap/bounce/void behaviors to bodies.
      function handleEdges() {
        const W=State.w, H=State.h, eb=CONFIG.edgeBehavior;
        if (eb==='wrap') {
          for (const b of State.bodies){
            if (b.x < 0) b.x += W; else if (b.x >= W) b.x -= W;
            if (b.y < 0) b.y += H; else if (b.y >= H) b.y -= H;
          }
        } else if (eb==='bounce') {
          for (const b of State.bodies){
            if (b.x - b.radius < 0 && b.vx < 0){ b.x = b.radius; b.vx = -b.vx; }
            if (b.x + b.radius > W && b.vx > 0){ b.x = W - b.radius; b.vx = -b.vx; }
            if (b.y - b.radius < 0 && b.vy < 0){ b.y = b.radius; b.vy = -b.vy; }
            if (b.y + b.radius > H && b.vy > 0){ b.y = H - b.radius; b.vy = -b.vy; }
          }
        } else if (eb==='void') {
          const keep=[]; const m=40;
          for (const b of State.bodies){
            if (b.x < -m || b.x > W+m || b.y < -m || b.y > H+m) continue; keep.push(b);
          }
          if (keep.length !== State.bodies.length) { State.bodies = keep; updateCapInfo(); }
        }
      }

      // ===============================
      // Collisions & Merging
      // ===============================
      // Purpose: Detect overlaps via spatial hash; merge inelastically.
      function rebuildHash() {
        State.hash.clear();
        const gs = CONFIG.gridSize;
        for (let i=0;i<State.bodies.length;i++){
          const b=State.bodies[i];
          const gx = Math.floor(b.x/gs), gy = Math.floor(b.y/gs);
          const key = gx+','+gy; if (!State.hash.has(key)) State.hash.set(key, []);
          State.hash.get(key).push(i);
        }
      }

      function resolveCollisions() {
        const bodies = State.bodies; const gs = CONFIG.gridSize;
        const removed = new Set(); rebuildHash();
        const nbh = [[0,0],[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]];
        for (let i=0;i<bodies.length;i++){
          if (removed.has(i)) continue; const A=bodies[i];
          const gx=Math.floor(A.x/gs), gy=Math.floor(A.y/gs);
          for (const [dx,dy] of nbh){
            const cell = State.hash.get((gx+dx)+','+(gy+dy)); if (!cell) continue;
            for (const j of cell){ if (j<=i || removed.has(j)) continue; const B=bodies[j];
              const dxp=B.x-A.x, dyp=B.y-A.y; const r=A.radius+B.radius;
              if (dxp*dxp + dyp*dyp <= r*r){
                // Check physical merge criteria
                if (shouldMerge(A, B)){
                  const [big, small, smallIdx] = (A.mass>=B.mass) ? [A,B,j] : [B,A,i];
                  mergeBodies(big, small);
                  removed.add(smallIdx);
                }
              }
            }
          }
        }
        if (removed.size){ State.bodies = bodies.filter((_,idx)=>!removed.has(idx)); updateCapInfo(); }
      }

      // Decide if two overlapping bodies should merge: require they are gravitationally bound
      // and have relative speed below escape speed at contact. In Solar System mode, protect
      // named majors (Sun/planets/moons) from merging.
      function isMajor(b){ return !!b.name; }
      function shouldMerge(A, B){
        // Protect majors when Solar mode is active
        if (State.solarMode && (isMajor(A) || isMajor(B))) return false;
        const dx=A.x-B.x, dy=A.y-B.y;
        const dvx=A.vx-B.vx, dvy=A.vy-B.vy;
        const r = Math.max(1e-6, Math.hypot(dx, dy));
        const mT = A.mass + B.mass;
        const mu = (A.mass*B.mass)/Math.max(mT,1e-12); // reduced mass
        const v2 = dvx*dvx + dvy*dvy;
        const rEff = Math.max(r, A.radius + B.radius);
        const vEsc2 = 2 * CONFIG.G * mT / Math.max(rEff, 1e-6);
        // Specific orbital energy (per reduced mass)
        const E = 0.5*v2 - CONFIG.G*mT/Math.max(r,1e-6);
        if (E >= 0) return false; // not bound
        if (v2 > (CONFIG.mergeVEscapeFactor*CONFIG.mergeVEscapeFactor)*vEsc2) return false; // too fast
        return true;
      }

      // Inelastic merge: conserve mass and momentum, recompute mix/density/radius/type.
      function mergeBodies(A, B) {
        const M = A.mass + B.mass; if (M<=0) return;
        const vx = (A.vx*A.mass + B.vx*B.mass) / M;
        const vy = (A.vy*A.mass + B.vy*B.mass) / M;
        const x = (A.x*A.mass + B.x*B.mass) / M;
        const y = (A.y*A.mass + B.y*B.mass) / M;
        const comp = {
          gas: (A.comp.gas*A.mass + B.comp.gas*B.mass)/M,
          rock: (A.comp.rock*A.mass + B.comp.rock*B.mass)/M,
          ice: (A.comp.ice*A.mass + B.comp.ice*B.mass)/M,
        };
        A.mass=M; A.vx=vx; A.vy=vy; A.x=x; A.y=y; A.comp=comp;
        A.density = mixDensity(comp);
        A.radius = radiusFromMassDensity(M, A.density);
        A.type = classify(A.mass, A.comp.gas);
        // Keep short trail by sampling last positions
        if (A.trail.length > (CONFIG.trailLength[State.trails]||0)) A.trail.splice(0, A.trail.length - (CONFIG.trailLength[State.trails]||0));
      }

      // ===============================
      // Painting & Eraser
      // ===============================
      // Purpose: Spawn bodies while dragging based on tool and sliders.
      function paintStep(dt) {
        if (!State.mouse.down) return;
        if (State.bodies.length >= CONFIG.maxBodies) return;

        // Use accumulator so spawn rate is stable across frame times.
        const rate = CONFIG.spawnRate; // dots per second
        State.spawnAccum += rate * dt;
        const dotsThisFrame = Math.min(50, Math.floor(State.spawnAccum));
        State.spawnAccum -= dotsThisFrame;
        const bx = State.mouse.x, by = State.mouse.y;
        const brush = (CONFIG.brushSize * State.dpr) / State.view.scale;
        const throwVX = State.mouse.throwing ? (State.mouse.x - State.mouse.lastX) * CONFIG.throwScale : 0;
        const throwVY = State.mouse.throwing ? (State.mouse.y - State.mouse.lastY) * CONFIG.throwScale : 0;

        if (State.tool === 'eraser') {
          // Eraser removes bodies within brush. Avoid deleting stars when brush is large.
          const eraseBigStars = brush <= 10; // small brush can target stars
          State.bodies = State.bodies.filter(b => {
            const dx=b.x-bx, dy=b.y-by; const hit = dx*dx+dy*dy <= brush*brush;
            if (!hit) return true;
            if (b.type==='star' && !eraseBigStars) return true; // protect star unless precise
            return false;
          });
          updateCapInfo();
          return;
        }

        for (let i=0;i<dotsThisFrame && State.bodies.length < CONFIG.maxBodies;i++){
          const ang = Math.random()*Math.PI*2; const rad = Math.random()*brush*0.6;
          const x = bx + Math.cos(ang)*rad; const y = by + Math.sin(ang)*rad;
          const mass = CONFIG.massPerDot * (0.6 + Math.random()*0.8);
          const comp = State.tool==='gas' ? {gas:0.95,rock:0.03,ice:0.02} :
                       State.tool==='rock'? {gas:0.05,rock:0.9, ice:0.05} :
                       {gas:0.1, rock:0.1, ice:0.8};

          // Orbit Assist: give new bodies a tangential velocity for circular orbit around largest star.
          let baseVX = 0, baseVY = 0;
          if (State.orbitAssist) {
            const star = largestStar();
            if (star) {
              const rx = x - star.x, ry = y - star.y; const r = Math.hypot(rx, ry);
              if (r > Math.max(10, star.radius * 1.2)) {
                const v = circularSpeed(CONFIG.G, star.mass, r);
                // Tangential unit vector (CCW)
                const tx = -ry / r, ty = rx / r;
                baseVX = tx * v; baseVY = ty * v;
              }
            }
          }

          // Throw adjusts eccentricity; small jitter to avoid perfect overlap
          const jitter = 0.6;
          const vx = baseVX + throwVX * 0.5 + (Math.random()-0.5)*jitter;
          const vy = baseVY + throwVY * 0.5 + (Math.random()-0.5)*jitter;
          State.bodies.push(createBody(x, y, mass, comp, vx, vy));
        }
      }

      // ===============================
      // Rendering
      // ===============================
      // Purpose: Draw background, trails fade, bodies, vectors, HUD, tooltip.
      function drawBackground(ctx) {
        const { w, h, bgStars } = State;
        const time = performance.now() * 0.001;
        
        ctx.save();
        
        // Enhanced space background with gradient
        const bgGradient = ctx.createRadialGradient(w * 0.5, h * 0.5, 0, w * 0.5, h * 0.5, Math.max(w, h) * 0.7);
        bgGradient.addColorStop(0, '#0a0f1a');
        bgGradient.addColorStop(0.5, '#05060a');
        bgGradient.addColorStop(1, '#020304');
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, w, h);
        
        // Add subtle nebula effects
        drawNebulae(ctx, w, h, time);
        
        // Enhanced starfield with varied sizes and colors
        drawEnhancedStarfield(ctx, w, h, bgStars, time);
        
        // Add cosmic dust lanes
        drawCosmicDust(ctx, w, h, time);
        
        ctx.restore();
      }
      
      // Draw subtle nebula effects in the background
      function drawNebulae(ctx, w, h, time) {
        ctx.globalAlpha = 0.08;
        
        // Large nebula regions
        const nebulae = [
          {x: 0.2, y: 0.3, size: 0.4, color: {r: 100, g: 50, b: 150}},
          {x: 0.7, y: 0.6, size: 0.35, color: {r: 150, g: 80, b: 60}},
          {x: 0.1, y: 0.8, size: 0.25, color: {r: 60, g: 120, b: 100}}
        ];
        
        nebulae.forEach((nebula, index) => {
          const centerX = nebula.x * w;
          const centerY = nebula.y * h;
          const radius = nebula.size * Math.min(w, h) * (1 + Math.sin(time * 0.1 + index) * 0.1);
          
          const nebulaGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
          nebulaGradient.addColorStop(0, `rgba(${nebula.color.r},${nebula.color.g},${nebula.color.b},0.15)`);
          nebulaGradient.addColorStop(0.3, `rgba(${nebula.color.r},${nebula.color.g},${nebula.color.b},0.08)`);
          nebulaGradient.addColorStop(0.7, `rgba(${nebula.color.r},${nebula.color.g},${nebula.color.b},0.03)`);
          nebulaGradient.addColorStop(1, 'rgba(0,0,0,0)');
          
          ctx.fillStyle = nebulaGradient;
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.fill();
        });
        
        ctx.globalAlpha = 1.0;
      }
      
      // Enhanced starfield with realistic variety
      function drawEnhancedStarfield(ctx, w, h, bgStars, time) {
        for (let i = 0; i < bgStars.length; i++) {
          const s = bgStars[i];
          const x = s.x * w;
          const y = s.y * h;
          
          // Star properties based on index for consistency
          const starSeed = i * 0.618033988749; // Golden ratio for good distribution
          const starType = (starSeed % 1);
          const brightness = s.a;
          const size = s.r;
          
          // Different star types with realistic colors
          let starColor;
          if (starType < 0.1) {
            // Blue giants (rare, bright)
            starColor = {r: 180, g: 200, b: 255};
            drawStar(ctx, x, y, size * 1.5, starColor, brightness * 1.3, time + i * 0.1);
          } else if (starType < 0.25) {
            // White/yellow stars
            starColor = {r: 255, g: 240, b: 200};
            drawStar(ctx, x, y, size * 1.2, starColor, brightness * 1.1, time + i * 0.1);
          } else if (starType < 0.65) {
            // Orange/red stars (most common)
            starColor = {r: 255, g: 180, b: 120};
            drawStar(ctx, x, y, size, starColor, brightness, time + i * 0.1);
          } else {
            // Red dwarfs (small, dim)
            starColor = {r: 255, g: 120, b: 80};
            drawStar(ctx, x, y, size * 0.8, starColor, brightness * 0.7, time + i * 0.1);
          }
        }
      }
      
      // Draw individual background star with twinkling
      function drawStar(ctx, x, y, size, color, brightness, timeOffset) {
        const twinkle = 0.8 + Math.sin(timeOffset * 3) * 0.2;
        const alpha = brightness * twinkle;
        
        ctx.globalAlpha = alpha;
        
        if (size > 1.2) {
          // Larger stars get a subtle glow
          const glowRadius = size * 2;
          const glowGradient = ctx.createRadialGradient(x, y, 0, x, y, glowRadius);
          glowGradient.addColorStop(0, `rgba(${color.r},${color.g},${color.b},0.3)`);
          glowGradient.addColorStop(0.5, `rgba(${color.r},${color.g},${color.b},0.1)`);
          glowGradient.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = glowGradient;
          ctx.beginPath();
          ctx.arc(x, y, glowRadius, 0, Math.PI * 2);
          ctx.fill();
          
          // Bright center
          ctx.fillStyle = `rgb(${color.r},${color.g},${color.b})`;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
          
          // Add cross flare for brightest stars
          if (size > 1.5) {
            ctx.strokeStyle = `rgba(${Math.min(255, color.r + 50)},${Math.min(255, color.g + 50)},${Math.min(255, color.b + 50)},0.8)`;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(x - size * 2, y);
            ctx.lineTo(x + size * 2, y);
            ctx.moveTo(x, y - size * 2);
            ctx.lineTo(x, y + size * 2);
            ctx.stroke();
          }
        } else {
          // Small stars are simple points
          ctx.fillStyle = `rgb(${color.r},${color.g},${color.b})`;
          ctx.fillRect(Math.floor(x), Math.floor(y), Math.ceil(size), Math.ceil(size));
        }
        
        ctx.globalAlpha = 1.0;
      }
      
      // Draw cosmic dust lanes for depth
      function drawCosmicDust(ctx, w, h, time) {
        ctx.globalAlpha = 0.05;
        
        // Dark dust lanes
        const dustLanes = [
          {x1: 0, y1: h * 0.2, x2: w, y2: h * 0.25, width: h * 0.08},
          {x1: 0, y1: h * 0.7, x2: w, y2: h * 0.75, width: h * 0.06},
          {x1: w * 0.2, y1: 0, x2: w * 0.3, y2: h, width: w * 0.04}
        ];
        
        dustLanes.forEach((lane, index) => {
          const gradient = ctx.createLinearGradient(
            lane.x1, lane.y1 - lane.width/2,
            lane.x1, lane.y1 + lane.width/2
          );
          gradient.addColorStop(0, 'rgba(0,0,0,0)');
          gradient.addColorStop(0.5, 'rgba(0,0,0,0.8)');
          gradient.addColorStop(1, 'rgba(0,0,0,0)');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.moveTo(lane.x1, lane.y1 - lane.width/2);
          ctx.lineTo(lane.x2, lane.y2 - lane.width/2);
          ctx.lineTo(lane.x2, lane.y2 + lane.width/2);
          ctx.lineTo(lane.x1, lane.y1 + lane.width/2);
          ctx.closePath();
          ctx.fill();
        });
        
        ctx.globalAlpha = 1.0;
      }
      
      // Enhanced trail rendering with particle-like effects and gradients
      function drawEnhancedTrails(ctx) {
        if (State.trails === 'off') return;
        
        const step = 1/CONFIG.physicsHz;
        const alpha = State.interpAlpha;
        
        ctx.save();
        ctx.setTransform(State.view.scale, 0, 0, State.view.scale, State.view.x, State.view.y);
        
        for (const body of State.bodies) {
          if (body.trail.length < 2) continue;
          
          // Get body color for trail
          const bodyCol = bodyColor(body);
          const speed = Math.hypot(body.vx, body.vy);
          
          // Enhanced trail properties based on body type and speed
          let trailColor, trailWidth, glowIntensity;
          
          if (body.type === 'star') {
            trailColor = bodyCol;
            trailWidth = Math.max(1, body.radius * 0.3);
            glowIntensity = 0.8;
          } else {
            trailColor = bodyCol;
            trailWidth = Math.max(0.5, body.radius * 0.2);
            glowIntensity = 0.4;
            
            // High-speed objects get comet-like trails
            if (speed > 50) {
              glowIntensity *= 1.5;
              trailWidth *= 1.3;
            }
          }
          
          // Draw trail segments with gradient fade
          const trailPoints = [...body.trail];
          // Add current interpolated position
          trailPoints.push({
            x: body.x + body.vx * step * alpha,
            y: body.y + body.vy * step * alpha
          });
          
          if (trailPoints.length < 2) continue;
          
          // Draw trail as connected segments with decreasing opacity
          for (let i = 1; i < trailPoints.length; i++) {
            const segmentAlpha = (i / trailPoints.length) * 0.7;
            const segmentWidth = trailWidth * (0.3 + segmentAlpha * 0.7);
            
            const p1 = trailPoints[i - 1];
            const p2 = trailPoints[i];
            
            // Skip if points are too close (prevents visual artifacts)
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 0.5) continue;
            
            // Draw glow effect for larger trails
            if (segmentWidth > 1 && glowIntensity > 0.3) {
              ctx.globalAlpha = segmentAlpha * glowIntensity * 0.3;
              ctx.strokeStyle = `rgb(${Math.min(255, trailColor.r + 50)},${Math.min(255, trailColor.g + 50)},${Math.min(255, trailColor.b + 50)})`;
              ctx.lineWidth = segmentWidth * 3;
              ctx.lineCap = 'round';
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
            }
            
            // Draw main trail segment
            ctx.globalAlpha = segmentAlpha;
            ctx.strokeStyle = `rgb(${trailColor.r},${trailColor.g},${trailColor.b})`;
            ctx.lineWidth = segmentWidth;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
            
            // Add particle sparkles for high-speed objects
            if (speed > 80 && Math.random() < 0.3) {
              const sparkleX = p1.x + (p2.x - p1.x) * Math.random();
              const sparkleY = p1.y + (p2.y - p1.y) * Math.random();
              
              ctx.globalAlpha = segmentAlpha * 0.6;
              ctx.fillStyle = `rgb(${Math.min(255, trailColor.r + 80)},${Math.min(255, trailColor.g + 80)},${Math.min(255, trailColor.b + 80)})`;
              ctx.beginPath();
              ctx.arc(sparkleX, sparkleY, 0.5, 0, Math.PI * 2);
              ctx.fill();
            }
          }
          
          // Add comet head glow for very fast objects
          if (speed > 100 && body.type !== 'star') {
            const currentPos = trailPoints[trailPoints.length - 1];
            ctx.globalAlpha = 0.4;
            
            const cometGradient = ctx.createRadialGradient(
              currentPos.x, currentPos.y, 0,
              currentPos.x, currentPos.y, body.radius * 2
            );
            cometGradient.addColorStop(0, `rgba(${trailColor.r + 100},${trailColor.g + 100},${trailColor.b + 100},0.8)`);
            cometGradient.addColorStop(0.5, `rgba(${trailColor.r},${trailColor.g},${trailColor.b},0.4)`);
            cometGradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            ctx.fillStyle = cometGradient;
            ctx.beginPath();
            ctx.arc(currentPos.x, currentPos.y, body.radius * 2, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        ctx.restore();
      }

      function drawTrailsFade(ctx) {
        const mode = State.trails; const fade = CONFIG.fadeAlpha[mode];
        if (mode==='off' || fade>=1.0) { ctx.clearRect(0,0,State.w,State.h); drawBackground(ctx); return; }
        ctx.fillStyle = `rgba(5,6,10,${fade})`;
        ctx.fillRect(0,0,State.w,State.h);
      }

      function bodyColor(b) {
        if (b.type==='star') {
          const sc = starColor(b.mass); return {r:sc.r,g:sc.g,b:sc.b};
        }
        if (b.comp.gas >= b.comp.ice && b.comp.gas >= b.comp.rock) return {r:240,g:225,b:170};
        if (b.comp.ice >= b.comp.gas && b.comp.ice >= b.comp.rock) return {r:170,g:230,b:255};
        return {r:205,g:150,b:100};
      }

      function drawBodies(ctx) {
        const step = 1/CONFIG.physicsHz; // base sim step for interpolation
        const alpha = State.interpAlpha;
        ctx.save();
        ctx.setTransform(State.view.scale, 0, 0, State.view.scale, State.view.x, State.view.y);
        for (const b of State.bodies) {
          const x = b.x + b.vx * step * alpha;
          const y = b.y + b.vy * step * alpha;
          const r = Math.max(1, b.radius);
          if (b.type === 'star') drawStarPixel(ctx, b, x, y, r);
          else drawPlanetPixel(ctx, b, x, y, r);
        }
        ctx.restore();
      }
      // Enhanced realistic star rendering with corona, flares, and proper stellar colors
      function drawStarPixel(ctx, b, x, y, r){
        const px = x, py = y;
        const rr = Math.max(2, r);
        const starCol = starColor(b.mass);
        const baseColor = `rgb(${starCol.r},${starCol.g},${starCol.b})`;
        const time = performance.now() * 0.001; // for animations
        
        ctx.save();
        
        // Draw corona/glow effect (largest, most diffuse)
        const coronaRadius = rr * 3.5;
        const coronaGradient = ctx.createRadialGradient(px, py, rr * 0.8, px, py, coronaRadius);
        coronaGradient.addColorStop(0, `rgba(${starCol.r},${starCol.g},${starCol.b},0.15)`);
        coronaGradient.addColorStop(0.3, `rgba(${starCol.r},${starCol.g},${starCol.b},0.08)`);
        coronaGradient.addColorStop(0.6, `rgba(${starCol.r},${starCol.g},${starCol.b},0.03)`);
        coronaGradient.addColorStop(1, `rgba(${starCol.r},${starCol.g},${starCol.b},0)`);
        ctx.fillStyle = coronaGradient;
        ctx.beginPath();
        ctx.arc(px, py, coronaRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw stellar atmosphere (medium glow)
        const atmosphereRadius = rr * 2.2;
        const atmosphereGradient = ctx.createRadialGradient(px, py, rr * 0.9, px, py, atmosphereRadius);
        atmosphereGradient.addColorStop(0, `rgba(${starCol.r},${starCol.g},${starCol.b},0.25)`);
        atmosphereGradient.addColorStop(0.5, `rgba(${starCol.r},${starCol.g},${starCol.b},0.12)`);
        atmosphereGradient.addColorStop(1, `rgba(${starCol.r},${starCol.g},${starCol.b},0)`);
        ctx.fillStyle = atmosphereGradient;
        ctx.beginPath();
        ctx.arc(px, py, atmosphereRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw main stellar disk with temperature gradient
        const diskGradient = ctx.createRadialGradient(px - rr * 0.3, py - rr * 0.3, 0, px, py, rr * 1.1);
        // Hotter center, cooler edges
        const centerTemp = Math.min(255, starCol.r + 40);
        const centerG = Math.min(255, starCol.g + 30);
        const centerB = Math.min(255, starCol.b + 20);
        diskGradient.addColorStop(0, `rgb(${centerTemp},${centerG},${centerB})`);
        diskGradient.addColorStop(0.7, baseColor);
        diskGradient.addColorStop(1, `rgb(${Math.max(0, starCol.r - 30)},${Math.max(0, starCol.g - 20)},${Math.max(0, starCol.b - 10)})`);
        
        ctx.fillStyle = diskGradient;
        ctx.beginPath();
        ctx.arc(px, py, rr, 0, Math.PI * 2);
        ctx.fill();
        
        // Add subtle stellar surface features (solar granulation effect)
        if (rr > 8) {
          ctx.globalAlpha = 0.15;
          for (let i = 0; i < 6; i++) {
            const angle = (time * 0.1 + i * Math.PI / 3) % (Math.PI * 2);
            const spotRadius = rr * (0.15 + Math.sin(time * 0.3 + i) * 0.05);
            const spotX = px + Math.cos(angle) * rr * 0.6;
            const spotY = py + Math.sin(angle) * rr * 0.6;
            const spotGradient = ctx.createRadialGradient(spotX, spotY, 0, spotX, spotY, spotRadius);
            spotGradient.addColorStop(0, `rgba(${Math.max(0, starCol.r - 50)},${Math.max(0, starCol.g - 30)},${Math.max(0, starCol.b - 20)},0.6)`);
            spotGradient.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = spotGradient;
            ctx.beginPath();
            ctx.arc(spotX, spotY, spotRadius, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1.0;
        }
        
        // Draw dynamic stellar flares/prominences
        const flareIntensity = 0.7 + Math.sin(time * 0.8 + b.id) * 0.3;
        ctx.globalAlpha = flareIntensity * 0.6;
        
        // Horizontal flare
        const flareLength = rr * (2.5 + Math.sin(time * 0.5) * 0.5);
        const flareGradient = ctx.createLinearGradient(px - flareLength, py, px + flareLength, py);
        flareGradient.addColorStop(0, 'rgba(255,255,255,0)');
        flareGradient.addColorStop(0.3, `rgba(${Math.min(255, starCol.r + 50)},${Math.min(255, starCol.g + 40)},${Math.min(255, starCol.b + 30)},0.8)`);
        flareGradient.addColorStop(0.7, `rgba(${Math.min(255, starCol.r + 50)},${Math.min(255, starCol.g + 40)},${Math.min(255, starCol.b + 30)},0.8)`);
        flareGradient.addColorStop(1, 'rgba(255,255,255,0)');
        
        ctx.strokeStyle = flareGradient;
        ctx.lineWidth = Math.max(1, rr * 0.15);
        ctx.beginPath();
        ctx.moveTo(px - flareLength, py);
        ctx.lineTo(px + flareLength, py);
        ctx.stroke();
        
        // Vertical flare
        const vFlareLength = rr * (2.2 + Math.cos(time * 0.7) * 0.4);
        const vFlareGradient = ctx.createLinearGradient(px, py - vFlareLength, px, py + vFlareLength);
        vFlareGradient.addColorStop(0, 'rgba(255,255,255,0)');
        vFlareGradient.addColorStop(0.3, `rgba(${Math.min(255, starCol.r + 50)},${Math.min(255, starCol.g + 40)},${Math.min(255, starCol.b + 30)},0.8)`);
        vFlareGradient.addColorStop(0.7, `rgba(${Math.min(255, starCol.r + 50)},${Math.min(255, starCol.g + 40)},${Math.min(255, starCol.b + 30)},0.8)`);
        vFlareGradient.addColorStop(1, 'rgba(255,255,255,0)');
        
        ctx.strokeStyle = vFlareGradient;
        ctx.beginPath();
        ctx.moveTo(px, py - vFlareLength);
        ctx.lineTo(px, py + vFlareLength);
        ctx.stroke();
        
        // Add twinkling effect for smaller stars
        if (rr < 6) {
          const twinkle = 0.8 + Math.sin(time * 2 + b.id * 1.3) * 0.2;
          ctx.globalAlpha = twinkle * 0.4;
          ctx.fillStyle = 'rgba(255,255,255,0.9)';
          ctx.beginPath();
          ctx.arc(px, py, rr * 0.3, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }

      // Enhanced realistic planet rendering with atmospheric effects, surface details, and proper lighting
      function drawPlanetPixel(ctx, b, x, y, r){
        const px = x, py = y;
        const rr = Math.max(2, r);
        const time = performance.now() * 0.001;
        
        // Determine planet type and colors
        const isGasGiant = b.comp.gas >= 0.55;
        const isIceGiant = b.comp.ice >= 0.55 && !isGasGiant;
        const isTerrestrial = !isGasGiant && !isIceGiant;
        
        // Get base colors based on composition
        let baseColor, lightColor, darkColor, atmosphereColor;
        if (isGasGiant) {
          baseColor = {r: 126, g: 200, b: 255};
          lightColor = {r: 180, g: 220, b: 255};
          darkColor = {r: 80, g: 140, b: 200};
          atmosphereColor = {r: 200, g: 230, b: 255};
        } else if (isIceGiant) {
          baseColor = {r: 191, g: 239, b: 255};
          lightColor = {r: 220, g: 250, b: 255};
          darkColor = {r: 140, g: 200, b: 230};
          atmosphereColor = {r: 210, g: 240, b: 255};
        } else {
          // Terrestrial - vary by composition
          if (b.comp.ice > 0.3) {
            baseColor = {r: 180, g: 200, b: 220};
            lightColor = {r: 220, g: 235, b: 245};
            darkColor = {r: 120, g: 140, b: 170};
          } else {
            baseColor = {r: 202, g: 163, b: 109};
            lightColor = {r: 240, g: 200, b: 150};
            darkColor = {r: 140, g: 110, b: 80};
          }
          atmosphereColor = {r: 180, g: 200, b: 230};
        }
        
        ctx.save();
        
        // Find nearest star for lighting direction
        let lightDir = {x: -0.5, y: -0.5}; // default lighting
        const nearestStar = nearestStarTo(b);
        if (nearestStar) {
          const dx = nearestStar.x - px;
          const dy = nearestStar.y - py;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 0) {
            lightDir = {x: dx / dist, y: dy / dist};
          }
        }
        
        // Draw atmosphere if planet is large enough
        if (rr > 4 && (isGasGiant || isIceGiant || b.comp.gas > 0.05)) {
          const atmRadius = rr * 1.15;
          const atmGradient = ctx.createRadialGradient(px, py, rr * 0.9, px, py, atmRadius);
          atmGradient.addColorStop(0, `rgba(${atmosphereColor.r},${atmosphereColor.g},${atmosphereColor.b},0)`);
          atmGradient.addColorStop(0.8, `rgba(${atmosphereColor.r},${atmosphereColor.g},${atmosphereColor.b},0.15)`);
          atmGradient.addColorStop(1, `rgba(${atmosphereColor.r},${atmosphereColor.g},${atmosphereColor.b},0.05)`);
          ctx.fillStyle = atmGradient;
          ctx.beginPath();
          ctx.arc(px, py, atmRadius, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw main planetary body with realistic lighting
        const bodyGradient = ctx.createRadialGradient(
          px + lightDir.x * rr * 0.3, py + lightDir.y * rr * 0.3, 0,
          px, py, rr * 1.2
        );
        bodyGradient.addColorStop(0, `rgb(${lightColor.r},${lightColor.g},${lightColor.b})`);
        bodyGradient.addColorStop(0.6, `rgb(${baseColor.r},${baseColor.g},${baseColor.b})`);
        bodyGradient.addColorStop(1, `rgb(${darkColor.r},${darkColor.g},${darkColor.b})`);
        
        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        ctx.arc(px, py, rr, 0, Math.PI * 2);
        ctx.fill();
        
        // Add surface features based on planet type
        if (isGasGiant && rr > 6) {
          // Gas giant bands
          drawGasGiantBands(ctx, px, py, rr, baseColor, b.id + time * 0.1);
        } else if (isIceGiant && rr > 5) {
          // Ice giant features
          drawIceGiantFeatures(ctx, px, py, rr, baseColor, b.id);
        } else if (isTerrestrial && rr > 4) {
          // Terrestrial surface features
          drawTerrestrialFeatures(ctx, px, py, rr, baseColor, b.id);
        }
        
        // Add terminator line (day/night boundary)
        if (rr > 3) {
          ctx.globalAlpha = 0.3;
          const terminatorGradient = ctx.createLinearGradient(
            px + lightDir.x * rr, py + lightDir.y * rr,
            px - lightDir.x * rr, py - lightDir.y * rr
          );
          terminatorGradient.addColorStop(0, 'rgba(0,0,0,0)');
          terminatorGradient.addColorStop(0.7, 'rgba(0,0,0,0)');
          terminatorGradient.addColorStop(1, 'rgba(0,0,0,0.8)');
          ctx.fillStyle = terminatorGradient;
          ctx.beginPath();
          ctx.arc(px, py, rr, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1.0;
        }
        
        // Enhanced rings for gas/ice giants
        if ((isGasGiant || isIceGiant) && rr > 6) {
          drawEnhancedRings(ctx, px, py, rr, lightDir, baseColor);
        }
        
        // Add subtle specular highlight
        if (rr > 3) {
          ctx.globalAlpha = 0.4;
          const highlightRadius = rr * 0.3;
          const highlightGradient = ctx.createRadialGradient(
            px + lightDir.x * rr * 0.4, py + lightDir.y * rr * 0.4, 0,
            px + lightDir.x * rr * 0.4, py + lightDir.y * rr * 0.4, highlightRadius
          );
          highlightGradient.addColorStop(0, 'rgba(255,255,255,0.6)');
          highlightGradient.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = highlightGradient;
          ctx.beginPath();
          ctx.arc(px + lightDir.x * rr * 0.4, py + lightDir.y * rr * 0.4, highlightRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1.0;
        }
        
        ctx.restore();
      }
      
      // Draw gas giant atmospheric bands
      function drawGasGiantBands(ctx, px, py, rr, baseColor, seed) {
        ctx.globalAlpha = 0.3;
        const bandCount = Math.floor(4 + (rr / 10) * 3);
        for (let i = 0; i < bandCount; i++) {
          const bandY = py + (i - bandCount/2) * (rr * 0.3);
          const bandHeight = rr * 0.2;
          const variation = Math.sin(seed + i * 0.5) * 20;
          
          ctx.fillStyle = `rgb(${Math.max(0, baseColor.r + variation)},${Math.max(0, baseColor.g + variation * 0.5)},${Math.max(0, baseColor.b + variation * 0.3)})`;
          ctx.beginPath();
          ctx.ellipse(px, bandY, rr * 0.9, bandHeight, 0, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Add great spot feature
        if (rr > 10) {
          ctx.fillStyle = `rgb(${Math.max(0, baseColor.r - 40)},${Math.max(0, baseColor.g - 20)},${Math.max(0, baseColor.b - 10)})`;
          ctx.beginPath();
          ctx.ellipse(px + rr * 0.3, py - rr * 0.2, rr * 0.25, rr * 0.15, 0.3, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1.0;
      }
      
      // Draw ice giant features
      function drawIceGiantFeatures(ctx, px, py, rr, baseColor, seed) {
        ctx.globalAlpha = 0.2;
        // Add subtle cloud patterns
        for (let i = 0; i < 3; i++) {
          const angle = (seed + i * 2.1) % (Math.PI * 2);
          const cloudX = px + Math.cos(angle) * rr * 0.4;
          const cloudY = py + Math.sin(angle) * rr * 0.4;
          const cloudRadius = rr * (0.2 + i * 0.1);
          
          const cloudGradient = ctx.createRadialGradient(cloudX, cloudY, 0, cloudX, cloudY, cloudRadius);
          cloudGradient.addColorStop(0, `rgba(${baseColor.r + 30},${baseColor.g + 20},${baseColor.b + 10},0.4)`);
          cloudGradient.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = cloudGradient;
          ctx.beginPath();
          ctx.arc(cloudX, cloudY, cloudRadius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1.0;
      }
      
      // Draw terrestrial planet features
      function drawTerrestrialFeatures(ctx, px, py, rr, baseColor, seed) {
        ctx.globalAlpha = 0.25;
        // Add continents/surface features
        const featureCount = Math.floor(3 + (rr / 8) * 2);
        for (let i = 0; i < featureCount; i++) {
          const angle = (seed * 0.7 + i * 1.8) % (Math.PI * 2);
          const featureX = px + Math.cos(angle) * rr * (0.3 + (i % 2) * 0.2);
          const featureY = py + Math.sin(angle) * rr * (0.3 + (i % 2) * 0.2);
          const featureRadius = rr * (0.15 + (i % 3) * 0.05);
          
          const variation = Math.sin(seed + i) * 30;
          ctx.fillStyle = `rgb(${Math.max(0, baseColor.r + variation)},${Math.max(0, baseColor.g + variation * 0.7)},${Math.max(0, baseColor.b + variation * 0.5)})`;
          ctx.beginPath();
          ctx.arc(featureX, featureY, featureRadius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1.0;
      }
      
      // Draw enhanced ring system
      function drawEnhancedRings(ctx, px, py, rr, lightDir, baseColor) {
        ctx.save();
        const tilt = 0.3;
        
        // Multiple ring bands with varying opacity and color
        const rings = [
          {inner: rr * 1.4, outer: rr * 1.8, alpha: 0.3, brightness: 1.0},
          {inner: rr * 1.9, outer: rr * 2.3, alpha: 0.2, brightness: 0.8},
          {inner: rr * 2.4, outer: rr * 2.6, alpha: 0.15, brightness: 0.6}
        ];
        
        rings.forEach((ring, index) => {
          ctx.globalAlpha = ring.alpha;
          
          // Ring lighting - brighter on the side facing the star
          const ringBrightness = ring.brightness * (0.7 + lightDir.x * 0.3);
          const ringColor = `rgb(${Math.floor(baseColor.r * ringBrightness)},${Math.floor(baseColor.g * ringBrightness)},${Math.floor(baseColor.b * ringBrightness)})`;
          
          ctx.strokeStyle = ringColor;
          ctx.lineWidth = (ring.outer - ring.inner) * 0.8;
          
          // Draw ring as ellipse
          ctx.beginPath();
          const avgRadius = (ring.inner + ring.outer) / 2;
          ctx.ellipse(px, py, avgRadius, avgRadius * Math.sin(tilt), 0, 0, Math.PI * 2);
          ctx.stroke();
        });
        
        // Add ring shadow on planet
        ctx.globalCompositeOperation = 'multiply';
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        
        // Shadow ellipse
        const shadowWidth = rr * 1.2;
        const shadowHeight = rr * 0.3;
        ctx.beginPath();
        ctx.ellipse(px - lightDir.x * rr * 0.1, py - lightDir.y * rr * 0.1, shadowWidth, shadowHeight, tilt, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }

      function drawRingsPixel(ctx, x, y, r){
        ctx.save();
        ctx.strokeStyle = '#e6dcc4'; ctx.globalAlpha = 0.6; ctx.lineWidth = 1;
        // Approximate tilted ellipse with two thin strokes
        ctx.beginPath(); ctx.ellipse(x, y, r*2.0, r*0.9, 0.3, 0, Math.PI*2); ctx.stroke();
        ctx.beginPath(); ctx.ellipse(x, y, r*1.5, r*0.7, 0.3, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
      }

      // Subtle banding for gas giants using semi-transparent latitudinal sweeps.
      function paintGasBands(ctx, x, y, r, palette, seed){
        const rng = seededRng(seed);
        const bands = Math.round(8 + Math.min(18, r*0.4));
        ctx.globalAlpha = 0.22;
        for (let i=0;i<bands;i++){
          const t = (i + 0.5)/bands; const latR = r * Math.cos((t-0.5)*Math.PI);
          const c = lerpColor(palette.dark, palette.light, 0.4 + 0.2*(rng()-0.5));
          ctx.strokeStyle = rgbStr(c);
          ctx.lineWidth = Math.max(1, r * (0.03 + rng()*0.02));
          ctx.beginPath(); ctx.ellipse(x, y, r*0.98, Math.abs(latR)*0.45, 0, 0, Math.PI*2); ctx.stroke();
        }
        ctx.globalAlpha = 1.0;
      }

      // Low-contrast blotchy albedo for rocky planets
      function paintRockAlbedo(ctx, x, y, r, palette, seed){
        const rng = seededRng(seed ^ 0xA53);
        const blotches = Math.round(10 + Math.min(24, r*0.8));
        for (let i=0;i<blotches;i++){
          const a = rng()*Math.PI*2, rr = r*(0.1 + rng()*0.8), br = r*(0.05 + rng()*0.08);
          const cx = x + Math.cos(a)*rr*0.6, cy = y + Math.sin(a)*rr*0.6;
          const col = lerpColor(palette.dark, palette.base, 0.3 + rng()*0.4);
          const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, br);
          g.addColorStop(0, rgbStr(col)); g.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.globalAlpha = 0.18; ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, br, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1.0;
      }

      // Specular highlights and faint streaks for icy worlds
      function paintIcyHighlights(ctx, x, y, r, palette, lx, ly, seed){
        // Specular near reflection direction (approx on dayside near limb)
        const hx = x + lx * r*0.4, hy = y + ly * r*0.4;
        const g = ctx.createRadialGradient(hx, hy, 0, hx, hy, r*0.7);
        g.addColorStop(0, 'rgba(255,255,255,0.9)'); g.addColorStop(0.3, rgbStr(palette.light)); g.addColorStop(1, 'rgba(255,255,255,0)');
        ctx.globalAlpha = 0.25; ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0;
      }

      // More realistic rings with inner/outer bands and planet shadow on rings
      function drawRingsRealistic(ctx, x, y, r, lx, ly){
        const tilt = 0.35; const outer = r*2.2, inner = r*1.3;
        ctx.save();
        // Draw rings (two bands)
        ctx.globalAlpha = 0.22; ctx.strokeStyle = '#e6dcc4'; ctx.lineWidth = Math.max(1, r*0.15);
        ctx.beginPath(); ctx.ellipse(x, y, outer, outer*0.55, tilt, 0, Math.PI*2); ctx.stroke();
        ctx.globalAlpha = 0.32; ctx.lineWidth = Math.max(1, r*0.28);
        ctx.beginPath(); ctx.ellipse(x, y, (inner+outer)/2, (inner+outer)/2*0.55, tilt, 0, Math.PI*2); ctx.stroke();

        // Planet shadow on rings: draw a dark ellipse segment behind planet along light direction
        ctx.globalCompositeOperation = 'multiply';
        ctx.globalAlpha = 0.25; ctx.fillStyle = 'rgba(0,0,0,0.7)';
        const sx = x - lx * r*0.3, sy = y - ly * r*0.3; // shadow center slightly behind planet
        ctx.beginPath(); ctx.ellipse(sx, sy, r*1.2, r*0.6, tilt, 0, Math.PI*2); ctx.fill();
        ctx.restore();
      }

      // Gas giants: latitudinal bands and a subtle storm.
      function drawGasBands(ctx, x, y, r, base, seed) {
        const rng = seededRng(seed);
        const bands = Math.round(6 + Math.min(18, r*0.6));
        for (let i=0;i<bands;i++) {
          const t = (i + 0.5)/bands; // -1..1 latitude
          const lat = Math.cos((t-0.5)*Math.PI)*r;
          const thickness = Math.max(1, r * (0.04 + rng()*0.03));
          const shift = (rng()-0.5)*0.3;
          const c1 = shade(base, (rng()-0.5)*0.15);
          ctx.strokeStyle = rgbStr(c1);
          ctx.globalAlpha = 0.35;
          ctx.lineWidth = thickness;
          ctx.beginPath();
          ctx.ellipse(x + r*0.05*shift, y, Math.max(0.1, r*0.98), lat*0.35, 0, 0, Math.PI*2);
          ctx.stroke();
        }
        // Great storm spot
        ctx.globalAlpha = 0.18; ctx.fillStyle = rgbStr(shade(base, -0.15));
        ctx.beginPath(); ctx.ellipse(x + r*0.35, y - r*0.1, r*0.35, r*0.22, 0.35, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 1.0;
      }

      // Rocky: a few soft craters (darker rims) for texture.
      function drawRockCraters(ctx, x, y, r, base, seed) {
        const rng = seededRng(seed ^ 0x9e3779b9);
        const count = Math.round(3 + Math.min(12, r*0.5));
        for (let i=0;i<count;i++) {
          const a = rng()*Math.PI*2; const rr = r*(0.2 + rng()*0.6);
          const cr = Math.max(0.6, r*(0.05 + rng()*0.06));
          const cx = x + Math.cos(a)*rr*0.6; const cy = y + Math.sin(a)*rr*0.6;
          const edge = shade(base, -0.18 - rng()*0.12);
          const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, cr);
          g.addColorStop(0, 'rgba(0,0,0,0.15)');
          g.addColorStop(0.6, rgbStr(shade(base, -0.05)));
          g.addColorStop(1, rgbStr(edge));
          ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx, cy, cr, 0, Math.PI*2); ctx.fill();
        }
      }

      // Icy: bright highlights and faint streaks.
      function drawIceSpecular(ctx, x, y, r, base, seed) {
        // Specular highlight
        const hlR = r*0.6; const hx = x - r*0.35, hy = y - r*0.35;
        const g1 = ctx.createRadialGradient(hx, hy, 0, hx, hy, hlR);
        g1.addColorStop(0, 'rgba(255,255,255,0.9)');
        g1.addColorStop(0.4, rgbStr(base));
        g1.addColorStop(1, 'rgba(255,255,255,0.06)');
        ctx.fillStyle = g1; ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();

        // Streaks
        const rng = seededRng(seed*2654435761);
        const lines = Math.round(4 + Math.min(14, r*0.4));
        ctx.save(); ctx.globalAlpha = 0.25; ctx.strokeStyle = 'rgba(240,255,255,0.7)'; ctx.lineWidth = Math.max(1, r*0.03);
        for (let i=0;i<lines;i++) {
          const ang = rng()*Math.PI*2; const len = r*(0.3 + rng()*0.6);
          const px = x + Math.cos(ang)*r*0.2; const py = y + Math.sin(ang)*r*0.2;
          ctx.beginPath(); ctx.moveTo(px - Math.cos(ang)*len*0.5, py - Math.sin(ang)*len*0.5);
          ctx.lineTo(px + Math.cos(ang)*len*0.5, py + Math.sin(ang)*len*0.5);
          ctx.stroke();
        }
        ctx.restore();
      }

      // Rings: multi-pass with inner gap and opacity gradient.
      function drawRings(ctx, x, y, r, color) {
        ctx.save();
        const tilt = 0.35; // radians
        const outer = r*2.2, inner = r*1.3;
        // Outer faint ring
        ctx.globalAlpha = 0.18; ctx.strokeStyle = color; ctx.lineWidth = Math.max(1, r*0.15);
        ctx.beginPath(); ctx.ellipse(x, y, outer, outer*0.55, tilt, 0, Math.PI*2); ctx.stroke();
        // Main ring band with gap
        ctx.globalAlpha = 0.35; ctx.lineWidth = Math.max(1, r*0.28);
        ctx.beginPath(); ctx.ellipse(x, y, (inner+outer)/2, (inner+outer)/2*0.55, tilt, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
      }
      
      // Draw dynamic visual effects like gravitational lensing and atmospheric effects
      function drawDynamicEffects(ctx) {
        const time = performance.now() * 0.001;
        
        ctx.save();
        ctx.setTransform(State.view.scale, 0, 0, State.view.scale, State.view.x, State.view.y);
        
        for (const body of State.bodies) {
          const step = 1/CONFIG.physicsHz;
          const alpha = State.interpAlpha;
          const x = body.x + body.vx * step * alpha;
          const y = body.y + body.vy * step * alpha;
          const r = body.radius;
          
          // Gravitational lensing effects for massive objects
          if (body.mass > CONFIG.planetMassThreshold * 5) {
            drawGravitationalLensing(ctx, x, y, r, body.mass, time + body.id * 0.1);
          }
          
          // Atmospheric scattering for planets with atmospheres
          if (body.type === 'planet' && (body.comp.gas > 0.05 || r > 8)) {
            drawAtmosphericScattering(ctx, x, y, r, body.comp, time + body.id * 0.2);
          }
          
          // Stellar wind effects for stars
          if (body.type === 'star' && r > 6) {
            drawStellarWind(ctx, x, y, r, body.mass, time + body.id * 0.15);
          }
        }
        
        ctx.restore();
      }
      
      // Draw subtle gravitational lensing effect
      function drawGravitationalLensing(ctx, x, y, r, mass, timeOffset) {
        const lensStrength = Math.min(0.1, mass / (CONFIG.starMassThreshold * 10));
        const lensRadius = r * (3 + Math.sin(timeOffset * 0.5) * 0.5);
        
        ctx.globalAlpha = lensStrength * 0.3;
        
        // Create subtle distortion ring
        const lensGradient = ctx.createRadialGradient(x, y, lensRadius * 0.8, x, y, lensRadius);
        lensGradient.addColorStop(0, 'rgba(255,255,255,0)');
        lensGradient.addColorStop(0.9, 'rgba(200,220,255,0.15)');
        lensGradient.addColorStop(1, 'rgba(255,255,255,0)');
        
        ctx.strokeStyle = lensGradient;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(x, y, lensRadius, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.globalAlpha = 1.0;
      }
      
      // Draw atmospheric scattering effects
      function drawAtmosphericScattering(ctx, x, y, r, composition, timeOffset) {
        if (r < 4) return;
        
        const atmThickness = r * 0.2;
        const scatterRadius = r + atmThickness;
        
        // Find light source direction
        let lightDir = {x: -0.5, y: -0.5};
        const nearestStar = nearestStarTo({x, y, comp: composition});
        if (nearestStar) {
          const dx = nearestStar.x - x;
          const dy = nearestStar.y - y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist > 0) {
            lightDir = {x: dx / dist, y: dy / dist};
          }
        }
        
        // Atmospheric glow on the lit side
        ctx.globalAlpha = 0.15;
        const litSideX = x + lightDir.x * r * 0.7;
        const litSideY = y + lightDir.y * r * 0.7;
        
        const atmGradient = ctx.createRadialGradient(litSideX, litSideY, 0, litSideX, litSideY, scatterRadius);
        
        // Color based on atmosphere composition
        let atmColor = {r: 180, g: 200, b: 230}; // Default blue
        if (composition.gas > 0.7) {
          atmColor = {r: 200, g: 180, b: 120}; // Yellowish for gas giants
        } else if (composition.ice > 0.3) {
          atmColor = {r: 150, g: 200, b: 255}; // Bluish for icy worlds
        }
        
        atmGradient.addColorStop(0, `rgba(${atmColor.r},${atmColor.g},${atmColor.b},0.4)`);
        atmGradient.addColorStop(0.7, `rgba(${atmColor.r},${atmColor.g},${atmColor.b},0.1)`);
        atmGradient.addColorStop(1, 'rgba(255,255,255,0)');
        
        ctx.fillStyle = atmGradient;
        ctx.beginPath();
        ctx.arc(x, y, scatterRadius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.globalAlpha = 1.0;
      }
      
      // Draw stellar wind particle effects
      function drawStellarWind(ctx, x, y, r, mass, timeOffset) {
        const windStrength = Math.min(1.0, mass / CONFIG.starMassThreshold);
        const windRadius = r * (4 + windStrength * 2);
        const particleCount = Math.floor(windStrength * 8);
        
        ctx.globalAlpha = 0.2;
        
        for (let i = 0; i < particleCount; i++) {
          const angle = (timeOffset * 0.3 + i * Math.PI * 2 / particleCount) % (Math.PI * 2);
          const distance = r * (2 + Math.sin(timeOffset * 0.8 + i) * 0.5);
          const particleX = x + Math.cos(angle) * distance;
          const particleY = y + Math.sin(angle) * distance;
          
          // Particle streak extending outward
          const streakLength = windStrength * 8;
          const endX = particleX + Math.cos(angle) * streakLength;
          const endY = particleY + Math.sin(angle) * streakLength;
          
          const particleGradient = ctx.createLinearGradient(particleX, particleY, endX, endY);
          particleGradient.addColorStop(0, 'rgba(255,240,200,0.6)');
          particleGradient.addColorStop(1, 'rgba(255,240,200,0)');
          
          ctx.strokeStyle = particleGradient;
          ctx.lineWidth = 0.5;
          ctx.beginPath();
          ctx.moveTo(particleX, particleY);
          ctx.lineTo(endX, endY);
          ctx.stroke();
        }
        
        ctx.globalAlpha = 1.0;
      }

      function drawVectors(ctx) {
        if (State.vectors==='off') return;
        ctx.save(); ctx.setTransform(State.view.scale, 0, 0, State.view.scale, State.view.x, State.view.y); ctx.lineWidth=1; ctx.strokeStyle = State.vectors==='vel' ? '#58e6a9' : '#ffb86b';
        const scale = State.vectors==='vel' ? CONFIG.vectorScaleVel : CONFIG.vectorScaleAcc;
        const step = 1/CONFIG.physicsHz; // base sim step for interpolation
        const alpha = State.interpAlpha;
        for (const b of State.bodies) {
          const px = b.x + b.vx * step * alpha;
          const py = b.y + b.vy * step * alpha;
          const vx = State.vectors==='vel' ? b.vx : b.ax*scale;
          const vy = State.vectors==='vel' ? b.vy : b.ay*scale;
          drawArrow(ctx, px, py, px + vx*0.8, py + vy*0.8);
        }
        ctx.restore();
      }

      // Draw a cursor arrow indicating circular orbit direction and magnitude
      function drawOrbitGuide(ctx) {
        if (!State.orbitGuide) return;
        const star = largestStar(); if (!star) return;
        const mx = State.mouse.x, my = State.mouse.y;
        const rx = mx - star.x, ry = my - star.y; const r = Math.hypot(rx, ry);
        if (r < Math.max(12, star.radius * 1.2)) return;
        const v = circularSpeed(CONFIG.G, star.mass, r);
        if (v <= 0) return;
        const tx = -ry / r, ty = rx / r; // tangential unit vector
        const len = v * CONFIG.orbitGuideScale;
        const x2 = mx + tx * len, y2 = my + ty * len;
        ctx.save(); ctx.setTransform(State.view.scale, 0, 0, State.view.scale, State.view.x, State.view.y);
        ctx.lineWidth = 1.5; ctx.strokeStyle = '#66b7ff';
        drawArrow(ctx, mx, my, x2, y2);
        // Label
        ctx.fillStyle = 'rgba(200,220,255,0.9)';
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        if (CONFIG.pxPerAU){
          const pxPerAU = CONFIG.pxPerAU;
          const vAU = v / pxPerAU;
          ctx.fillText(`v_circ ${vAU.toFixed(3)} AU/yr`, x2 + 6, y2 + 2);
        } else {
          ctx.fillText(`v_circ ${v.toFixed(2)} px/sim`, x2 + 6, y2 + 2);
        }
        ctx.restore();
      }

      // Draws a small arrow from (x1,y1) to (x2,y2).
      function drawArrow(ctx,x1,y1,x2,y2){
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
        const ang=Math.atan2(y2-y1,x2-x1), len=6; ctx.beginPath();
        ctx.moveTo(x2,y2);
        ctx.lineTo(x2 - Math.cos(ang-0.4)*len, y2 - Math.sin(ang-0.4)*len);
        ctx.moveTo(x2,y2);
        ctx.lineTo(x2 - Math.cos(ang+0.4)*len, y2 - Math.sin(ang+0.4)*len);
        ctx.stroke();
      }

      function drawHUD() {
        const hud = document.getElementById('hud');
        const inv = State.invariants, inv0 = State.invariants0;
        let eDrift = '—', lDrift = '—';
        if (inv && inv0 && Math.abs(inv0.E) > 0) {
          eDrift = `${(((inv.E - inv0.E) / inv0.E) * 100).toFixed(2)}%`;
        }
        if (inv && inv0) {
          const L0 = Math.hypot(inv0.Lx||0, inv0.Ly||0, inv0.Lz||0);
          const L = Math.hypot(inv.Lx||0, inv.Ly||0, inv.Lz||0);
          if (L0 > 0) lDrift = `${(((L - L0) / L0) * 100).toFixed(2)}%`;
        }
        const dtStr = `${(State.lastDt || 0).toFixed(5)} ${State.solarMode? 'yr' : 's'}`;
        const t = [
          `Bodies: ${State.bodies.length}/${CONFIG.maxBodies}`,
          `FPS: ${State.fps.toFixed(0)}`,
          `dt: ${dtStr}`,
          `ΔE: ${eDrift} • Δ|L|: ${lDrift}`,
          `Tool: ${State.tool} • Trails: ${State.trails} • Edge: ${CONFIG.edgeBehavior}`,
          State.paused ? 'Paused' : 'Running'
        ].join('  |  ');
        hud.textContent = t;
      }

      // Draw labels for named bodies (planets, major moons)
      function drawLabels(ctx){
        ctx.save(); ctx.setTransform(State.view.scale, 0, 0, State.view.scale, State.view.x, State.view.y);
        ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, Arial';
        ctx.textBaseline = 'top';
        for (const b of State.bodies){
          if (!b.name) continue;
          const step = 1/CONFIG.physicsHz;
          const alpha = State.interpAlpha;
          const x = b.x + b.vx * step * alpha;
          const y = b.y + b.vy * step * alpha;
          const padX = 8, padY = -4;
          const label = b.name;
          // shadow for readability
          ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillText(label, x + padX + 1, y + padY + 1);
          ctx.fillStyle = 'rgba(230,240,255,0.95)'; ctx.fillText(label, x + padX, y + padY);
        }
        ctx.restore();
      }

      // Apply pixelation pass: downscale then upscale with nearest-neighbor
      function applyPixelation() {
        if (!CONFIG.pixelArt || !State.pxCanvas || !State.pxCtx) return;
        const ps = Math.max(1, Math.floor(CONFIG.pixelSize || 1));
        const pw = Math.max(1, Math.floor(State.w / ps));
        const ph = Math.max(1, Math.floor(State.h / ps));
        if (State.pxCanvas.width !== pw || State.pxCanvas.height !== ph) {
          State.pxCanvas.width = pw; State.pxCanvas.height = ph;
        }
        // Downscale current frame into px canvas
        State.pxCtx.imageSmoothingEnabled = false;
        State.pxCtx.clearRect(0,0,pw,ph);
        State.pxCtx.drawImage(State.canvas, 0, 0, pw, ph);
        // Blit back up with nearest-neighbor
        State.ctx.imageSmoothingEnabled = false;
        State.ctx.clearRect(0,0,State.w,State.h);
        State.ctx.drawImage(State.pxCanvas, 0, 0, State.w, State.h);
      }

      function simYearSeconds(){
        // Normalize periods to Earth=1 year using current scale
        const sun = largestStar(); if (!sun || !CONFIG.pxPerAU) return null;
        const mu = CONFIG.G * sun.mass;
        const a = CONFIG.pxPerAU; // 1 AU in px
        return 2*Math.PI * Math.sqrt((a*a*a)/mu);
      }

      // ===============================
      // Invariants (Energy, Momentum, Angular Momentum)
      // ===============================
      function computeInvariants(){
        let Ex = 0, Ey = 0; // not used, but keep placeholders
        let K = 0; // kinetic
        let U = 0; // potential (pair sum)
        let Px = 0, Py = 0; // linear momentum
        let Lz = 0; // 2D system angular momentum z
        const n = State.bodies.length;
        for (let i=0;i<n;i++){
          const b = State.bodies[i];
          K += 0.5 * b.mass * (b.vx*b.vx + b.vy*b.vy);
          Px += b.mass * b.vx; Py += b.mass * b.vy;
        }
        for (let i=0;i<n;i++){
          const A = State.bodies[i];
          for (let j=i+1;j<n;j++){
            const B = State.bodies[j];
            const dx = B.x - A.x, dy = B.y - A.y;
            const r = Math.sqrt(dx*dx + dy*dy + perPairSoftening2(A,B));
            U += - CONFIG.G * A.mass * B.mass / r;
          }
        }
        for (let i=0;i<n;i++){
          const b = State.bodies[i];
          Lz += b.mass * (b.x*b.vy - b.y*b.vx);
        }
        return { E: K+U, K, U, Px, Py, Lx:0, Ly:0, Lz };
      }

      function orbitalParams(body){
        const sun = largestStar(); if (!sun) return null;
        const mu = CONFIG.G * sun.mass;
        const dx = body.x - sun.x, dy = body.y - sun.y; const r = Math.hypot(dx, dy);
        const v2 = body.vx*body.vx + body.vy*body.vy;
        const E = 0.5*v2 - mu/r; if (E >= 0) return { bound:false };
        const a = -mu/(2*E);
        const T = 2*Math.PI * Math.sqrt((a*a*a)/mu);
        const yearSec = simYearSeconds();
        const years = yearSec ? (T / yearSec) : null;
        const aAU = CONFIG.pxPerAU ? (a / CONFIG.pxPerAU) : null;
        return { bound:true, a, T, years, aAU };
      }

      // ===============================
      // Validation (Solar System)
      // ===============================
      function cloneBodies(src){
        return src.map(b=>({
          id:b.id, x:b.x, y:b.y, vx:b.vx, vy:b.vy, ax:0, ay:0,
          mass:b.mass, radius:b.radius, density:b.density, comp:{...b.comp}, type:b.type, name:b.name
        }));
      }
      function findByName(arr, name){ return arr.find(b=>b.name===name) || null; }
      function unwrapDelta(prev, curr){ let d = curr - prev; if (d > Math.PI) d -= 2*Math.PI; else if (d < -Math.PI) d += 2*Math.PI; return d; }
      function validateYears(years, opts){
        if (!State.solarMode || !CONFIG.pxPerAU) return { ok:false, reason:'Not in Solar System mode' };
        const etaOrig = CONFIG.adaptive?.eta || 0.06;
        const attempts = (opts&&opts.autoTune)? 2 : 0;
        let best=null;
        for (let attempt=0; attempt<=attempts; attempt++){
          if (attempt>0) CONFIG.adaptive.eta = Math.max(etaOrig*0.5, CONFIG.adaptive.eta*0.7);
          const rep = simulateValidation(years);
          best = rep;
          if (rep.ok) break;
        }
        CONFIG.adaptive.eta = etaOrig;
        return best || { ok:false, reason:'Unknown' };
      }
      function simulateValidation(years){
        const saved = { minTau: State.minPairTau, lastDt: State.lastDt, lastAd: State.lastAdaptiveDt, inv: State.invariants, inv0: State.invariants0 };
        const bodies = cloneBodies(State.bodies);
        // Initialize accelerations
        computeAccelerations(bodies);
        let t = 0;
        let earth = findByName(bodies, 'Earth');
        let jupiter = findByName(bodies, 'Jupiter');
        let neptune = findByName(bodies, 'Neptune');
        const sun = findByName(bodies, 'Sun');
        const track = [earth, jupiter, neptune].map(p=>({ body:p, prev: p? Math.atan2(p.y-sun.y, p.x-sun.x) : 0, sum:0 }));
        const inv0 = computeInvariantsFor(bodies);
        while (t < years) {
          // Estimate adaptive dt from last minPairTau (set by computeAccelerations inside integrate)
          const tau = Math.max(1e-6, State.minPairTau || (1/CONFIG.physicsHz));
          const dt = Math.min(CONFIG.adaptive.dtMax, Math.max(CONFIG.adaptive.dtMin, CONFIG.adaptive.eta * tau));
          integrate(bodies, dt);
          t += dt;
          if (sun){
            for (const tr of track){ if (!tr.body) continue; const a = Math.atan2(tr.body.y - sun.y, tr.body.x - sun.x); tr.sum += unwrapDelta(tr.prev, a); tr.prev = a; }
          }
        }
        const inv1 = computeInvariantsFor(bodies);
        const eDrift = Math.abs((inv1.E - inv0.E) / Math.max(Math.abs(inv0.E), 1e-12));
        const expect = { Earth:1.0, Jupiter:11.86, Neptune:164.8 };
        const errs = {};
        if (earth){ const rev = track[0].sum/(2*Math.PI); errs.Earth = Math.abs((t/(rev||1e-9) - expect.Earth)/expect.Earth); }
        if (jupiter){ const rev = track[1].sum/(2*Math.PI); errs.Jupiter = Math.abs((t/(rev||1e-9) - expect.Jupiter)/expect.Jupiter); }
        if (neptune){ const rev = track[2].sum/(2*Math.PI); errs.Neptune = Math.abs((t/(rev||1e-9) - expect.Neptune)/expect.Neptune); }
        // Thresholds
        const ok = eDrift < 0.005 && (errs.Earth==null || errs.Earth < 0.01) && (errs.Jupiter==null || errs.Jupiter < 0.03) && (errs.Neptune==null || errs.Neptune < 0.06);
        // Restore globals
        State.minPairTau = saved.minTau; State.lastDt = saved.lastDt; State.lastAdaptiveDt = saved.lastAd; State.invariants = saved.inv; State.invariants0 = saved.inv0;
        return { ok, eDrift, errs, years:t };
      }
      function computeInvariantsFor(arr){
        let K=0,U=0,Px=0,Py=0,Lz=0; const n=arr.length;
        for (let i=0;i<n;i++){ const b=arr[i]; K+=0.5*b.mass*(b.vx*b.vx+b.vy*b.vy); Px+=b.mass*b.vx; Py+=b.mass*b.vy; }
        for (let i=0;i<n;i++){ const A=arr[i]; for (let j=i+1;j<n;j++){ const B=arr[j]; const dx=B.x-A.x, dy=B.y-A.y; const r=Math.sqrt(dx*dx+dy*dy+perPairSoftening2(A,B)); U += -CONFIG.G*A.mass*B.mass/r; }}
        for (let i=0;i<n;i++){ const b=arr[i]; Lz += b.mass*(b.x*b.vy - b.y*b.vx); }
        return {E:K+U,K,U,Px,Py,Lz};
      }

      function drawTooltip() {
        const tip = document.getElementById('tooltip');
        const id = State.hoverId; if (id==null) { tip.style.display='none'; return; }
        const b = State.bodies.find(o=>o.id===id); if (!b) { tip.style.display='none'; return; }
        const speed = Math.hypot(b.vx, b.vy);
        const gasPct = Math.round(b.comp.gas*100), rockPct=Math.round(b.comp.rock*100), icePct=Math.round(b.comp.ice*100);
        const subtype = b.type==='planet'? ` (${planetSubtype(b.comp)})` : '';
        const star = b.type==='star'? starColor(b.mass) : null;
        // Compute v/v_circ relative to largest star, when meaningful
        let vvCirc = '—';
        const s = largestStar();
        if (s && b.id !== s.id) {
          const rx = b.x - s.x, ry = b.y - s.y; const r = Math.hypot(rx, ry);
          const minR = Math.max(12, s.radius * 1.2);
          if (r > minR) {
            const vCirc = circularSpeed(CONFIG.G, s.mass, r);
            if (vCirc > 0) vvCirc = (speed / vCirc).toFixed(2);
          }
        }
        const orb = orbitalParams(b);
        const name = b.name ? `${b.name} — ` : '';
        const aStr = (orb && orb.aAU)? ` • a ≈ ${orb.aAU.toFixed(2)} AU` : '';
        const Tstr = (orb && orb.years!=null)? ` • P ≈ ${orb.years.toFixed(2)} yr` : '';
        const dtStr = `${(State.lastDt||0).toFixed(5)} ${State.solarMode? 'yr' : 's'}`;
        tip.innerHTML = `<div><strong>${name}${b.type}${subtype}</strong>${star?` • Temp: ${Math.round(star.temp)}K`:''}${aStr}${Tstr}</div>
          <div>Mass: ${b.mass.toFixed(1)}</div>
          <div>Radius: ${b.radius.toFixed(1)} px</div>
          <div>Velocity: ${(speed/(CONFIG.pxPerAU||1)).toFixed(3)} AU/yr</div>
          <div>v/v_circ: ${vvCirc}</div>
          <div>dt: ${dtStr}</div>
          <div>Comp: gas ${gasPct}%, rock ${rockPct}%, ice ${icePct}%</div>`;
        const rect = State.canvas.getBoundingClientRect();
        tip.style.left = `${rect.left + (State.mouse.sx/State.dpr) + 14}px`;
        tip.style.top = `${rect.top + (State.mouse.sy/State.dpr) + 14}px`;
        tip.style.display = 'block';
      }

      // ===============================
      // Serialization (localStorage)
      // ===============================
      // Purpose: Save and load scene/config to localStorage.
      function saveToLocalStorage(){
        const payload = {
          version: 1,
          config: {
            G: CONFIG.G, softening: CONFIG.softening, timeScale: CONFIG.timeScale,
            starMassThreshold: CONFIG.starMassThreshold, planetMassThreshold: CONFIG.planetMassThreshold,
            igniteGasFraction: CONFIG.igniteGasFraction, edgeBehavior: CONFIG.edgeBehavior,
            brushSize: CONFIG.brushSize, massPerDot: CONFIG.massPerDot, spawnRate: CONFIG.spawnRate,
            speedBoost: CONFIG.speedBoost,
            trails: State.trails, vectors: State.vectors,
            orbitAssist: State.orbitAssist, orbitGuide: State.orbitGuide
          },
          bodies: State.bodies.map(b=>({ id:b.id,x:b.x,y:b.y,vx:b.vx,vy:b.vy,mass:b.mass,comp:b.comp }))
        };
        localStorage.setItem(CONFIG.saveKey, JSON.stringify(payload));
        flashHUD('Saved ✓');
      }

      function loadFromLocalStorage(){
        const raw = localStorage.getItem(CONFIG.saveKey);
        if (!raw) { flashHUD('No save found'); return; }
        try{
          const data = JSON.parse(raw);
          CONFIG.G = data.config?.G ?? CONFIG.G;
          CONFIG.softening = data.config?.softening ?? CONFIG.softening;
          CONFIG.timeScale = data.config?.timeScale ?? CONFIG.timeScale;
          CONFIG.starMassThreshold = data.config?.starMassThreshold ?? CONFIG.starMassThreshold;
          CONFIG.planetMassThreshold = data.config?.planetMassThreshold ?? CONFIG.planetMassThreshold;
          CONFIG.igniteGasFraction = data.config?.igniteGasFraction ?? CONFIG.igniteGasFraction;
          CONFIG.edgeBehavior = data.config?.edgeBehavior ?? CONFIG.edgeBehavior;
          CONFIG.brushSize = data.config?.brushSize ?? CONFIG.brushSize;
          CONFIG.massPerDot = data.config?.massPerDot ?? CONFIG.massPerDot;
          CONFIG.spawnRate = data.config?.spawnRate ?? CONFIG.spawnRate;
          CONFIG.speedBoost = data.config?.speedBoost ?? CONFIG.speedBoost;
          State.trails = data.config?.trails ?? State.trails;
          State.vectors = data.config?.vectors ?? State.vectors;
          State.orbitAssist = data.config?.orbitAssist ?? State.orbitAssist;
          State.orbitGuide = data.config?.orbitGuide ?? State.orbitGuide;

          State.bodies = data.bodies.map(b=>createBody(b.x, b.y, b.mass, b.comp, b.vx, b.vy));
          syncControls(); updateCapInfo();
          flashHUD('Loaded ✓');
        } catch(e){ console.error(e); flashHUD('Load failed'); }
      }

      function syncControls(){
        const set = (id,v)=>{ const el=document.getElementById(id); el.value=String(v); el.dispatchEvent(new Event('input')); };
        set('gravity', CONFIG.G); set('timeScale', CONFIG.timeScale); set('softening', CONFIG.softening);
        set('starThreshold', CONFIG.starMassThreshold); set('planetThreshold', CONFIG.planetMassThreshold); set('igniteFrac', CONFIG.igniteGasFraction);
        set('brushSize', CONFIG.brushSize); set('massPerDot', CONFIG.massPerDot); set('spawnRate', CONFIG.spawnRate);
        document.getElementById('trails').value = State.trails;
        document.getElementById('vectors').value = State.vectors;
        document.getElementById('edge').value = CONFIG.edgeBehavior;
        document.getElementById('orbitAssist').checked = State.orbitAssist;
        document.getElementById('orbitGuide').checked = State.orbitGuide;
        const sb = document.getElementById('speedBoost'); sb.value = String(CONFIG.speedBoost); sb.dispatchEvent(new Event('input'));
      }

      // ===============================
      // Seeds
      // ===============================
      // Purpose: Demo system and random belt around largest star.
      function clearBodies(){ State.bodies.length=0; updateCapInfo(); flashHUD('Cleared'); }

      function addDefaultStar(){
        const cx = State.w/2, cy = State.h/2;
        const star = createBody(cx, cy, CONFIG.starMassThreshold*1.1, {gas:0.9,rock:0.08,ice:0.02}, 0, 0);
        State.bodies.push(star);
      }

      function largestStar(){ let s=null; for (const b of State.bodies) if (b.type==='star' && (!s || b.mass>s.mass)) s=b; return s; }

      function seedDemo(){
        clearBodies();
        const cx = State.w/2, cy = State.h/2;
        // Sandbox units
        State.solarMode = false; CONFIG.yearsPerSecond = 0.0;
        const star = createBody(cx, cy, CONFIG.starMassThreshold*1.2, {gas:0.85,rock:0.1,ice:0.05}, 0, 0);
        State.bodies.push(star);
        const mkPlanet=(r, m, comp)=>{
          const a=Math.random()*Math.PI*2; const x=cx+r*Math.cos(a), y=cy+r*Math.sin(a);
          // Circular speed around central star
          const v = circularSpeed(CONFIG.G, star.mass, r) * (0.95 + Math.random()*0.1);
          const tx = -Math.sin(a), ty = Math.cos(a);
          const vx = tx * v, vy = ty * v;
          State.bodies.push(createBody(x,y,m,comp,vx,vy));
        };
        mkPlanet(160, CONFIG.planetMassThreshold*1.2, {gas:0.1,rock:0.85,ice:0.05});
        mkPlanet(280, CONFIG.planetMassThreshold*3.0, {gas:0.7,rock:0.25,ice:0.05});
        mkPlanet(380, CONFIG.planetMassThreshold*2.4, {gas:0.25,rock:0.2,ice:0.55});
        for (let i=0;i<90;i++){
          const r=460 + Math.random()*50; const a=Math.random()*Math.PI*2; const x=cx+r*Math.cos(a), y=cy+r*Math.sin(a);
          const v = circularSpeed(CONFIG.G, star.mass, r) * (0.9 + Math.random()*0.2);
          const vx=-Math.sin(a)*v, vy=Math.cos(a)*v;
          const m=2+Math.random()*3; const comp = Math.random()<0.6 ? {gas:0.1,rock:0.7,ice:0.2} : {gas:0.2,rock:0.2,ice:0.6};
          State.bodies.push(createBody(x,y,m,comp,vx,vy));
        }
        updateCapInfo(); flashHUD('Demo seeded');
        State.invariants0 = computeInvariants();
      }

      function seedRandomBelt(){
        let s = largestStar(); if (!s) { addDefaultStar(); s = largestStar(); }
        if (!s) return;
        State.solarMode = false; CONFIG.yearsPerSecond = 0.0;
        const cx=s.x, cy=s.y; const base=260+Math.random()*160; const spread=60; const count=120+Math.floor(Math.random()*120);
        for (let i=0;i<count && State.bodies.length<CONFIG.maxBodies;i++){
          const r=base + (Math.random()-0.5)*spread; const ang=Math.random()*Math.PI*2;
          const x=cx+r*Math.cos(ang), y=cy+r*Math.sin(ang);
          const vc = circularSpeed(CONFIG.G, s.mass, r) * (0.9 + Math.random()*0.2);
          const dir = Math.random() < 0.92 ? 1 : -1;
          const vx=-Math.sin(ang)*vc*dir, vy=Math.cos(ang)*vc*dir;
          const m=1+Math.random()*3; const mix=Math.random();
          const comp = mix<0.4?{gas:0.1,rock:0.7,ice:0.2}: mix<0.8?{gas:0.2,rock:0.2,ice:0.6}:{gas:0.6,rock:0.3,ice:0.1};
          State.bodies.push(createBody(x,y,m,comp,vx,vy));
        }
        updateCapInfo(); flashHUD('Belt added');
        State.invariants0 = computeInvariants();
      }

      // Real Solar System preset with approximate masses, radii (AU), and eccentricities.
      function seedSolarSystem(){
        clearBodies();
        const cx = State.w/2, cy = State.h/2;
        // Unit system: AU (distance), years (time), Msun (mass)
        // Choose pixel scale so Neptune (~30 AU) fits nicely on screen.
        const pxPerAU = Math.min(State.w, State.h) * 0.42 / 30.07; // px per AU
        CONFIG.pxPerAU = pxPerAU;
        // Set G in pixel/year^2 units: G_ast = 4*pi^2 AU^3/(yr^2 Msun)
        // Convert to pixels: G_px = G_ast * pxPerAU^3
        const G_ast = 4*Math.PI*Math.PI;
        CONFIG.G = G_ast * pxPerAU * pxPerAU * pxPerAU;
        // Small softening relative to AU for numerical stability (reduced for moons) and disable radius-based softening in Solar mode
        CONFIG.softening = Math.max(0.0001, 0.0005 * pxPerAU);
        CONFIG.softeningK = 0.0;
        // Time mapping: years per real second
        CONFIG.yearsPerSecond = 0.12; // ~0.12 yr/s by default
        State.solarMode = true;
        // Reset adaptive dt defaults for Solar mode (in years)
        State.lastAdaptiveDt = 1/240;
        State.lastDt = 1/240;
        // Mass scale: Sun = 1 Msun; Earth = 3.003e-6 Msun
        const M_sun = 1.0; // Msun
        const mEarth = 3.003e-6; // Msun

        // Create Sun (gas heavy)
        const Sun = createBody(cx, cy, M_sun, {gas:0.98, rock:0.015, ice:0.005}, 0, 0);
        Sun.type = 'star';
        Sun.name = 'Sun';
        State.bodies.push(Sun);

        // Helper to place a planet with eccentricity using vis-viva in 2D plane
        function placePlanet(AU, e, massEarths, comp, omega, f){
          const a = AU * pxPerAU; // semi-major axis in px
          const mu = CONFIG.G * Sun.mass;
          const r = a * (1 - e*e) / (1 + e*Math.cos(f));
          // Perifocal frame
          const x_pf = r * Math.cos(f);
          const y_pf = r * Math.sin(f);
          const k = Math.sqrt(mu/a) / Math.sqrt(1 - e*e);
          const vx_pf = -k * Math.sin(f);
          const vy_pf =  k * (e + Math.cos(f));
          // Rotate by argument of periapsis omega
          const co = Math.cos(omega), so = Math.sin(omega);
          const x = cx + x_pf*co - y_pf*so;
          const y = cy + x_pf*so + y_pf*co;
          const vx = vx_pf*co - vy_pf*so;
          const vy = vx_pf*so + vy_pf*co;
          const mass = massEarths * mEarth;
          const body = createBody(x, y, mass, comp, vx, vy);
          body.type = 'planet';
          return body;
        }

        // Orbital elements: AU, eccentricity e, mass (Earths), composition, omega (rad), f (true anomaly rad)
        const planets = [
          ['Mercury', 0.387, 0.2056, 0.0553, {gas:0.02, rock:0.95, ice:0.03}, 0.4, 0.0],
          ['Venus',   0.723, 0.0068, 0.815,  {gas:0.03, rock:0.94, ice:0.03}, 1.0, 1.2],
          ['Earth',   1.000, 0.0167, 1.0,    {gas:0.02, rock:0.95, ice:0.03}, 0.2, 2.1],
          ['Mars',    1.524, 0.0934, 0.107,  {gas:0.02, rock:0.90, ice:0.08}, 0.8, 3.0],
          ['Jupiter', 5.203, 0.0489, 317.8,  {gas:0.88, rock:0.10, ice:0.02}, 0.7, 1.8],
          ['Saturn',  9.537, 0.0565, 95.2,   {gas:0.85, rock:0.10, ice:0.05}, 1.3, 2.5],
          ['Uranus', 19.191, 0.0472, 14.5,   {gas:0.20, rock:0.25, ice:0.55}, 2.0, 4.1],
          ['Neptune',30.07,  0.0086, 17.1,   {gas:0.20, rock:0.20, ice:0.60}, 2.6, 5.0],
        ];
        const placed = [];
        for (const [name, aAU, e, mE, comp, omega, f] of planets){
          const p = placePlanet(aAU, e, mE, comp, omega, f);
          p.name = name;
          placed.push(p);
          State.bodies.push(p);
        }

        // Moons (selected major ones): distances in AU, circular approx
        function addMoon(planetName, moonName, aMoonAU, mMoonEarths, comp){
          const planet = State.bodies.find(b=>b.name===planetName);
          if (!planet) return;
          let r = aMoonAU * pxPerAU;
          // Keep physical separation; do not enlarge orbit for visibility
          const ang = Math.random()*Math.PI*2;
          const x = planet.x + r*Math.cos(ang);
          const y = planet.y + r*Math.sin(ang);
          const muP = CONFIG.G * planet.mass;
          const vrel = Math.sqrt(muP / r);
          const tx = -Math.sin(ang), ty = Math.cos(ang);
          const vx = planet.vx + tx * vrel;
          const vy = planet.vy + ty * vrel;
          const mass = mMoonEarths * mEarth; // Msun
          const moon = createBody(x, y, mass, comp, vx, vy);
          moon.name = moonName; moon.type = 'planet'; // treat visually as planet
          State.bodies.push(moon);
        }

        // Earth-Moon
        addMoon('Earth', 'Moon', 0.00257, 0.0123, {gas:0.0, rock:0.9, ice:0.1});
        // Galilean moons
        addMoon('Jupiter', 'Io',       0.00282, 0.015, {gas:0.0, rock:0.7, ice:0.3});
        addMoon('Jupiter', 'Europa',   0.00449, 0.008, {gas:0.0, rock:0.6, ice:0.4});
        addMoon('Jupiter', 'Ganymede', 0.00716, 0.025, {gas:0.0, rock:0.5, ice:0.5});
        addMoon('Jupiter', 'Callisto', 0.01257, 0.018, {gas:0.0, rock:0.4, ice:0.6});
        // Saturn's Titan
        addMoon('Saturn', 'Titan', 0.00817, 0.0225, {gas:0.0, rock:0.5, ice:0.5});

        // Asteroid belt (rocky debris)
        const beltCount = 200;
        for (let i=0;i<beltCount && State.bodies.length<CONFIG.maxBodies;i++){
          const aAU = 2.2 + Math.random()*1.0; // 2.2–3.2 AU
          const e = Math.min(0.25, Math.abs((Math.random()-0.5))*0.4);
          const f = Math.random()*Math.PI*2;
          const omega = Math.random()*Math.PI*2;
          const a = aAU * pxPerAU; const mu = CONFIG.G * Sun.mass;
          const r = a * (1 - e*e) / (1 + e*Math.cos(f));
          const x_pf = r*Math.cos(f), y_pf = r*Math.sin(f);
          const k = Math.sqrt(mu/a) / Math.sqrt(1 - e*e);
          const vx_pf = -k*Math.sin(f), vy_pf = k*(e+Math.cos(f));
          const co=Math.cos(omega), so=Math.sin(omega);
          const x = cx + x_pf*co - y_pf*so;
          const y = cy + x_pf*so + y_pf*co;
          const vx = vx_pf*co - vy_pf*so;
          const vy = vx_pf*so + vy_pf*co;
          const m = 0.0001 + Math.random()*0.0015; // tiny masses
          const comp = {gas:0.02, rock:0.9, ice:0.08};
          const ast = createBody(x, y, m*mEarth, comp, vx, vy);
          State.bodies.push(ast);
        }

        // Zero total momentum (barycentric frame) for stability
        let Mtot = 0, Px = 0, Py = 0;
        for (const b of State.bodies) { Mtot += b.mass; Px += b.mass * b.vx; Py += b.mass * b.vy; }
        if (Mtot > 0) {
          const vxcm = Px / Mtot, vycm = Py / Mtot;
          for (const b of State.bodies) { b.vx -= vxcm; b.vy -= vycm; }
        }

        updateCapInfo(); flashHUD('Solar System seeded');
        // Baseline invariants after seeding
        State.invariants0 = computeInvariants();
      }

      // Creates a stable, randomized solar system with near-circular orbits,
      // varied planet types, occasional moons, and a debris belt.
      function seedPresetSystem(){
        clearBodies();
        const cx = State.w/2, cy = State.h/2;
        State.solarMode = false; CONFIG.yearsPerSecond = 0.0;
        // Central star: heavier to keep barycenter near center
        const starMass = CONFIG.starMassThreshold * (1.5 + Math.random()*0.4);
        const star = createBody(cx, cy, starMass, {gas:0.92,rock:0.06,ice:0.02}, 0, 0);
        State.bodies.push(star);

        // Planets: 5–8 spaced roughly geometrically from 140 px outward
        const nPlanets = 5 + Math.floor(Math.random()*4);
        const baseR = 140 + Math.random()*30;
        const spacing = 1.35 + Math.random()*0.25; // geometric spacing
        let r = baseR;
        const planets = [];
        for (let i=0; i<nPlanets && State.bodies.length < CONFIG.maxBodies; i++) {
          const a = Math.random()*Math.PI*2;
          const x = cx + r*Math.cos(a), y = cy + r*Math.sin(a);
          // Composition + mass by zone
          let comp, mass;
          if (r < baseR*1.8) {
            // Inner rocky
            comp = {gas:0.08, rock:0.86, ice:0.06};
            mass = CONFIG.planetMassThreshold * (0.6 + Math.random()*1.0);
          } else if (r < baseR*3.0) {
            // Transition / super-earth / mini-neptune
            const t = Math.random();
            if (t < 0.5) { comp = {gas:0.15, rock:0.7, ice:0.15}; }
            else { comp = {gas:0.5, rock:0.25, ice:0.25}; }
            mass = CONFIG.planetMassThreshold * (1.2 + Math.random()*2.0);
          } else {
            // Outer giants (gas or ice)
            if (Math.random() < 0.6) comp = {gas:0.75, rock:0.15, ice:0.10};
            else comp = {gas:0.25, rock:0.15, ice:0.60};
            mass = CONFIG.planetMassThreshold * (2.0 + Math.random()*4.0);
          }
          // Near-circular orbital speed with slight eccentricity/jitter
          const vCirc = circularSpeed(CONFIG.G, star.mass, r);
          const v = vCirc * (0.97 + Math.random()*0.06);
          const tx = -Math.sin(a), ty = Math.cos(a);
          const jitter = 0.4;
          const vx = tx * v + (Math.random()-0.5)*jitter;
          const vy = ty * v + (Math.random()-0.5)*jitter;
          const planet = createBody(x, y, mass, comp, vx, vy);
          State.bodies.push(planet);
          planets.push({body: planet, r});
          r *= spacing * (1.05 + Math.random()*0.05);
        }

        // Optional moons for the 1–2 most massive outer planets
        const heavy = planets
          .filter(p => p.r > baseR*2.2)
          .sort((a,b)=>b.body.mass - a.body.mass)
          .slice(0, 2);
        for (const host of heavy) {
          const moons = 1 + Math.floor(Math.random()*2);
          for (let k=0; k<moons && State.bodies.length < CONFIG.maxBodies; k++) {
            const pr = host.body.radius * (5 + Math.random()*6); // orbital radius around planet
            const ang = Math.random()*Math.PI*2;
            const mx = host.body.x + pr*Math.cos(ang);
            const my = host.body.y + pr*Math.sin(ang);
            const vm = circularSpeed(CONFIG.G, host.body.mass, pr) * (0.95 + Math.random()*0.1);
            const tx = -Math.sin(ang), ty = Math.cos(ang);
            const mmass = Math.max(1.0, host.body.mass * (0.02 + Math.random()*0.04));
            const mcomp = {gas:0.05, rock:0.8, ice:0.15};
            const mvx = host.body.vx + tx*vm;
            const mvy = host.body.vy + ty*vm;
            State.bodies.push(createBody(mx, my, mmass, mcomp, mvx, mvy));
          }
        }

        // Debris belt beyond last planet
        const lastR = r * 0.9;
        const beltCount = 100 + Math.floor(Math.random()*120);
        for (let i=0;i<beltCount && State.bodies.length < CONFIG.maxBodies;i++){
          const rr = lastR + 40 + Math.random()*80; const ang=Math.random()*Math.PI*2;
          const x = cx + rr*Math.cos(ang), y = cy + rr*Math.sin(ang);
          const vc = circularSpeed(CONFIG.G, star.mass, rr) * (0.9 + Math.random()*0.2);
          const dir = Math.random()<0.96?1:-1; const vx=-Math.sin(ang)*vc*dir, vy=Math.cos(ang)*vc*dir;
          const m = 0.8 + Math.random()*2.2;
          const t = Math.random();
          const comp = t<0.5? {gas:0.05,rock:0.75,ice:0.20} : {gas:0.15,rock:0.25,ice:0.60};
          State.bodies.push(createBody(x,y,m,comp,vx,vy));
        }

        updateCapInfo(); flashHUD('Preset system seeded');
        State.invariants0 = computeInvariants();
      }

      // ===============================
      // Main Loop
      // ===============================
      // Purpose: Advance physics and render each frame.
      function frame(nowMs){
        const now = nowMs/1000; let dtReal = now - State.lastTime; State.lastTime = now;
        dtReal = Math.min(CONFIG.maxDt, Math.max(0, dtReal));
        // Spawn painting based on real time
        paintStep(dtReal);
        // Fixed-step physics for smoothness (in simulation time)
        const step = 1 / CONFIG.physicsHz;
        if (!State.paused) {
          // Accumulate simulation time scaled by time controls
          const timeScale = getTimeScale();
          const realToSim = State.solarMode ? (CONFIG.yearsPerSecond || 0) : 1.0;
          State.accum += dtReal * timeScale * realToSim;
          let steps = 0, maxSteps = Math.min(240, Math.max(12, Math.ceil(12 * timeScale)));
          while (State.accum > 0 && steps < maxSteps) {
            // Adaptive dt from last computed dynamical timescale
            let dt = step;
            if (CONFIG.adaptive) {
              const eta = CONFIG.adaptive.eta;
              const dtMin = CONFIG.adaptive.dtMin;
              const dtMax = CONFIG.adaptive.dtMax;
              const tau = Math.max(1e-6, State.minPairTau || step);
              let target = Math.min(dtMax, Math.max(dtMin, eta * tau));
              // Smooth changes in dt to keep leapfrog stable
              const last = State.lastAdaptiveDt || target;
              const limit = CONFIG.adaptive.smoothChange || 2.0;
              const lo = last/limit, hi = last*limit;
              target = Math.min(hi, Math.max(lo, target));
              dt = Math.min(State.accum, target);
              State.lastAdaptiveDt = target;
              State.lastDt = dt;
            } else {
              dt = Math.min(State.accum, step);
              State.lastDt = dt;
            }
            integrate(State.bodies, dt);
            handleEdges();
            resolveCollisions();
            steps++;
            State.accum -= dt;
            // Recompute invariants occasionally (throttled)
            State.invTimer += dt;
            if (State.invTimer >= (State.solarMode ? 1/24 : 0.25)) { // roughly per sim day or 0.25s
              State.invariants = computeInvariants();
              State.invTimer = 0;
              if (!State.invariants0) State.invariants0 = State.invariants;
            }
          }
          // Avoid spiral of death: drop extra time if too slow
          if (steps === maxSteps) State.accum = 0;
        }
        // Interpolation alpha for ultra-smooth rendering
        State.interpAlpha = clamp(State.accum / step, 0, 1);

        // Trails sampling (once per frame is fine)
        const maxLen = CONFIG.trailLength[State.trails] || 0;
        if (maxLen>0) {
          for (const b of State.bodies) { b.trail.push({x:b.x, y:b.y}); if (b.trail.length>maxLen) b.trail.shift(); }
        } else { for (const b of State.bodies) b.trail.length = 0; }

        // Rendering
        const ctx = State.ctx;
        // Draw simulation to base layer, then optional pixelation
        drawTrailsFade(ctx);
        if (State.trails==='off') drawBackground(ctx);
        // Draw enhanced trails before bodies
        if (State.trails !== 'off') drawEnhancedTrails(ctx);
        drawBodies(ctx);
        applyPixelation();
        // Overlays remain crisp
        drawDynamicEffects(ctx);
        drawVectors(ctx);
        drawOrbitGuide(ctx);
        drawLabels(ctx);
        drawHUD();

        // Hover picking for tooltip
        pickHover(); drawTooltip();

        // FPS
        fpsTick(dtReal);
        // Track last mouse pos for throwing
        State.mouse.lastX = State.mouse.x; State.mouse.lastY = State.mouse.y;
        requestAnimationFrame(frame);
      }

      function fpsTick(dt){ State.fpsAccum += dt; State.fpsFrames++; if (State.fpsAccum >= 0.4){ State.fps = State.fpsFrames/State.fpsAccum; State.fpsAccum=0; State.fpsFrames=0; } }

      // Finds nearest body to mouse within pick radius.
      function pickHover(){
        const px = State.mouse.x, py = State.mouse.y; const pr = (CONFIG.pickRadius * State.dpr) / State.view.scale; let best=null, bestD2=pr*pr;
        for (const b of State.bodies){ const dx=b.x-px, dy=b.y-py; const d2=dx*dx+dy*dy; if (d2<bestD2){ best=b; bestD2=d2; } }
        State.hoverId = best? best.id : null;
      }

      function flashHUD(text){ const hud=document.getElementById('hud'); const old=hud.textContent; hud.textContent = text + ' • ' + old; setTimeout(()=>drawHUD(), 800); }

      // ===============================
      // Boot
      // ===============================
      initCanvas(); bindUI(); initInput(); drawBackground(State.ctx); drawHUD();
      // Initialize accelerations and baseline invariants for monitoring
      computeAccelerations(State.bodies);
      State.invariants0 = computeInvariants();
  requestAnimationFrame(frame);
  </script>
  
  </body>
  </html>
